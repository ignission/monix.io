<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Task &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/eval/task.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="Task &amp;mdash; Monix" />
  <meta name="twitter:description" content="このデータ型は非同期の計算や、副作用の制御、不確定性の回避、コールバック地獄の回避に役立ちます。" />
  <meta name="twitter:url" content="https://monix.io/docs/current/eval/task.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="Task &amp;mdash; Monix" property="og:title">
  <meta content="このデータ型は非同期の計算や、副作用の制御、不確定性の回避、コールバック地獄の回避に役立ちます。" property="og:description">
  <meta content="https://monix.io/docs/current/eval/task.html" property="og:url">
  <meta content="2021-07-06T00:33:05+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1625754182468065957">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1625754182468065957">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          Task
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2021-07-06">
    <b>ページの更新日:</b> 06 Jul 2021
  </time>
  <nav role="navigation" id="type-info">
    <a href="/api/current/monix/eval/Task.html">APIドキュメント</a>
    <a href="https://github.com/monix/monix/blob/v3.4.0/monix-eval/shared/src/main/scala/monix/eval/Task.scala">ソースコード</a>
    
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/eval/task.md">ページを編集</a>
    
  </nav>
  
  <div id="version3x">
    最新のMonix 3.xシリーズのドキュメントが表示されています。<br/>
    古いバージョン:
    
      <a href="/docs/2x/eval/task.html">2.x</a>
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#イントロダクション">イントロダクション</a>
    <ul>
      <li><a href="#設計の概要">設計の概要</a></li>
      <li><a href="#scalaのfutureとの比較">ScalaのFutureとの比較</a></li>
      <li><a href="#scalazのtaskとの比較">ScalazのTaskとの比較</a></li>
    </ul>
  </li>
  <li><a href="#実行-runtofuture--foreach">実行 (runToFuture &amp; foreach)</a>
    <ul>
      <li><a href="#結果をブロッキングする">結果をブロッキングする</a></li>
      <li><a href="#即時実行を試みる">即時実行を試みる</a></li>
    </ul>
  </li>
  <li><a href="#シンプルなビルダー">シンプルなビルダー</a>
    <ul>
      <li><a href="#tasknow">Task.now</a></li>
      <li><a href="#taskeval-遅延">Task.eval (遅延)</a></li>
      <li><a href="#taskevalonce">Task.evalOnce</a></li>
      <li><a href="#taskdefer-延期">Task.defer (延期)</a></li>
      <li><a href="#taskfromfuture">Task.fromFuture</a></li>
      <li><a href="#taskdeferfuture">Task.deferFuture</a></li>
      <li><a href="#taskdeferfutureaction">Task.deferFutureAction</a></li>
      <li><a href="#taskexecuteasync-taskasyncboundary-taskexecuteon">Task.executeAsync, Task.asyncBoundary, Task.executeOn</a></li>
      <li><a href="#taskraiseerror">Task.raiseError</a></li>
      <li><a href="#tasknever">Task.never</a></li>
      <li><a href="#taskunit">Task.unit</a></li>
    </ul>
  </li>
  <li><a href="#非同期型ビルダー">非同期型ビルダー</a>
    <ul>
      <li><a href="#taskcreate">Task.create</a></li>
    </ul>
  </li>
  <li><a href="#メモ化">メモ化</a>
    <ul>
      <li><a href="#成功したときだけメモ化する">成功したときだけメモ化する</a></li>
      <li><a href="#memoizeとruntofutureの比較">MemoizeとrunToFutureの比較</a></li>
    </ul>
  </li>
  <li><a href="#操作">操作</a>
    <ul>
      <li><a href="#flatmapと末尾再帰ループ">FlatMapと末尾再帰ループ</a></li>
      <li><a href="#並列性-catsparallel">並列性 (cats.Parallel)</a></li>
      <li><a href="#taskのシーケンスから結果を収集する">Taskのシーケンスから結果を収集する</a></li>
      <li><a href="#race">Race</a></li>
      <li><a href="#race-many">Race Many</a></li>
      <li><a href="#遅延実行">遅延実行</a></li>
      <li><a href="#結果の遅延シグナリング">結果の遅延シグナリング</a></li>
      <li><a href="#述語が真になるまで再起動">述語が真になるまで再起動</a></li>
      <li><a href="#終了時にリソースをのクリーンアップ">終了時にリソースをのクリーンアップ</a></li>
      <li><a href="#リアクティブパブリッシャーへの変換">リアクティブ・パブリッシャーへの変換</a></li>
    </ul>
  </li>
  <li><a href="#エラーハンドリング">エラーハンドリング</a>
    <ul>
      <li><a href="#エラーロギングのオーバーライド">エラーロギングのオーバーライド</a></li>
      <li><a href="#タイムアウトのトリガー">タイムアウトのトリガー</a></li>
      <li><a href="#エラーからの回復">エラーからの回復</a></li>
      <li><a href="#エラーのときに再起動する">エラーのときに再起動する</a></li>
      <li><a href="#エラーを公開する">エラーを公開する</a></li>
    </ul>
  </li>
</ul>

  </nav>
    
      <h2 id="イントロダクション">
        
        
          イントロダクション <a href="#イントロダクション" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Task</code>は遅延する可能性のある、非同期計算を制御するためのデータ型です。副作用の制御や非決定論やコールバック地獄の回避に役立ちます。</p>

<p>importを整理します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Taskを評価するためには、Schedulerが必要です</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// キャンセル可能なFuture型</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>

<span class="c1">// Taskはmonix.eval内にあります</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sumを実行すると、(applyのセマンティクスにより)別のスレッドで発生します</span>
<span class="c1">// しかし、このインスタンスの構築時には何も起こりません</span>
<span class="c1">// この表現は純粋で、単なる仕様です。Taskはデフォルトでは遅延動作をします ;-)</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>

<span class="c1">// TaskはrunToFutureでのみ評価されます</span>
<span class="c1">// コールバックスタイル:</span>
<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//=&gt; 2</span>

<span class="c1">// または、Futureに変換することもできます</span>
<span class="k">val</span> <span class="nv">future</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// 結果を非同期にプリントします</span>
<span class="nv">future</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 2</span>
</code></pre></div></div>
    
      <h3 id="設計の概要">
        
        
          設計の概要 <a href="#設計の概要" class="anchor">#</a>
        
        
      </h3>

<p>Monixの<code class="language-plaintext highlighter-rouge">Task</code>を要約します:</p>

<ul>
  <li>遅延 &amp; 非同期評価</li>
  <li>1つのプロデューサーが1つまたは複数のコンシューマーに1つの値だけをプッシュするモデル</li>
  <li><a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a>をきめ細かく制御することができる</li>
  <li><code class="language-plaintext highlighter-rouge">runToFuture</code>が呼ばれるまでは、実行やその効果は引き起こされません</li>
  <li>必ずしも別の論理スレッドで実行する必要はありません</li>
  <li>実行中の計算をキャンセルすることができます</li>
  <li>Haskellの機能と同様に副作用を制御することができます(HaskellのI/Oと同じような効果があります)</li>
  <li>実装上、スレッドをブロックすることはありません</li>
  <li>スレッドをブロックするようなAPIコールを公開していません</li>
</ul>

<p>これらの仕様を表にまとめます:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">先行</th>
      <th style="text-align: center">遅延</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>同期</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="/docs/current/eval/coeval.html">Coeval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>非同期</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">Task[A]</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="scalaのfutureとの比較">
        
        
          ScalaのFutureとの比較 <a href="#scalaのfutureとの比較" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>はScalaの <a href="http://docs.scala-lang.org/overviews/core/futures.html">Future</a>と似ていますが違った性格を持っており、この2つのタイプは実際には補完関係にあることがわかります。<br />
賢い人はかつてこう言いました。</p>

<blockquote>
  <p>“<em>未来は時間から切り離された価値を表す</em>” — Viktor Klang</p>
</blockquote>

<p>価値とは何か、時間とは何かを考えさせられる詩的な発想ですね。
しかし、より重要なことは<code class="language-plaintext highlighter-rouge">Future</code>が <a href="https://en.wikipedia.org/wiki/Value_(computer_science)">値</a>であるとは言えないものの、<em>値になりたがっている</em> とは確実に言えるということです。
つまり、<code class="language-plaintext highlighter-rouge">Future</code>の参照を受け取ったとき、それを評価しようとしているどんなプロセスも、おそらくすでに始まっていて、またすでに終了しているかもしれません。
これにより、Scalaの<code class="language-plaintext highlighter-rouge">Future</code>の動作は <em>先行評価</em> となり、<code class="language-plaintext highlighter-rouge">map</code>や<code class="language-plaintext highlighter-rouge">flatMap</code>のような演算子を呼ぶときに、どのように暗黙の実行コンテキストを取るかを考えれば、確かにその設計は助けになります。</p>

<p>しかし、<code class="language-plaintext highlighter-rouge">Task</code>は違います。Taskは<code class="language-plaintext highlighter-rouge">遅延評価</code>です。実際、<code class="language-plaintext highlighter-rouge">Task</code>では実行モデルを微調整することができますが、これが両者の主な違いです。
<code class="language-plaintext highlighter-rouge">Future</code>が値のようなものなら、<code class="language-plaintext highlighter-rouge">Task</code>は関数のようなものです。そして実際に、<code class="language-plaintext highlighter-rouge">Task</code>は<code class="language-plaintext highlighter-rouge">Future</code>インスタンスの「ファクトリー」として機能します。</p>

<p>もうひとつの特徴は、<code class="language-plaintext highlighter-rouge">Future</code>はデフォルトで「<em>メモ化</em>される」ということです。
つまり、必要に応じて複数のコンシューマー間で共有されます。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>の評価は、デフォルトではメモ化されません。メモ化を実現するためには、明示的に指定しなければなりません。</p>

<p>先行評価の動作を持つ<code class="language-plaintext highlighter-rouge">Future</code>は、効率面で劣ります。
というのも、どのような操作を行っても実装は最終的にスレッドプールに<code class="language-plaintext highlighter-rouge">Runnable</code>インスタンスを送ることになり、結果が各ステップで常にメモ化されるからです。
一方、<code class="language-plaintext highlighter-rouge">Task</code>は同期的なバッチで実行することができます。</p>
    
      <h3 id="scalazのtaskとの比較">
        
        
          ScalazのTaskとの比較 <a href="#scalazのtaskとの比較" class="anchor">#</a>
        
        
      </h3>

<p>MonixのTaskが、<a href="https://github.com/scalaz/scalaz">Scalaz</a>のTaskにインスパイアされたことは周知の事実です。Monixライブラリ全体が巨人の肩の上に立っています。<br />
Monix Taskの実装が異なる点は:</p>

<ol>
  <li>ScalazのTaskは実装の詳細を漏らしています。
というのも、ScalazのTaskはまず<em>トランポリン</em>実行を目的としていますが、非同期実行は非同期のトランポリン境界を飛び越えることを目的としているからです。
例えば、大きなループで現在のスレッドをブロックしないようにするには、<code class="language-plaintext highlighter-rouge">Task.executeAsync</code>を使って非同期の境界を手動で挿入しなければなりません。
一方、MonixのTaskは、デフォルトで自動的にそれを行うようになっています。
これは、<a href="http://www.scala-js.org/">Javascript</a>の上で実行するときに非常に便利です。
<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">協調的マルチタスク</a>はあったほうがいいだけでなく、必要なのです。</li>
  <li>ScalazのTaskは同期/非同期の2面を持っています。これは生産者にとっては最適化のために良いことです(例えば、必要がないのになぜスレッドをフォークするのか)。
しかし、コンシューマの視点から見ると、<code class="language-plaintext highlighter-rouge">def run: A</code>は、JavascriptやJVM上でAPIを完全にサポートできないことを意味します。
つまり、Scalazの<code class="language-plaintext highlighter-rouge">Task</code>は結局、同期評価やスレッドのブロックを偽装することになるのです。
そして、<a href="/docs/current/best-practices/blocking.html">スレッドをブロックすることは非常に安全ではありません</a></li>
  <li>ScalazのTaskは、実行中の計算をキャンセルすることはできません。これは非決定論的な操作では重要です。
例えば、<code class="language-plaintext highlighter-rouge">race</code>で競合状態を作ったときに、時間内に終わらなかった遅いTaskをキャンセルしたい場合があります。
というのもリソースをすぐに解放しないと、残念ながら深刻なリークが発生してプロセスがクラッシュしてしまうことがあるからです。</li>
  <li>ScalazのTaskは、非同期実行を扱うJavaの標準ライブラリを利用しています。
これはポータビリティの観点からは好ましくありません。このAPIは<a href="http://www.scala-js.org/">Scala.js</a>の上ではサポートされていないからです。</li>
</ol>
    
      <h2 id="実行-runtofuture--foreach">
        
        
          実行 (runToFuture &amp; foreach) <a href="#実行-runtofuture--foreach" class="anchor">#</a>
        
        
      </h2>

<p>Taskインスタンスは、<code class="language-plaintext highlighter-rouge">runToFuture</code>によって実行されるまで何もしません。また、複数のオーバーロードがあります。</p>

<p><code class="language-plaintext highlighter-rouge">Task.runToFuture</code>では<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を継承した<a href="/docs/current/execution/scheduler.html">Scheduler</a>を暗黙のパラメータとして求められます。
しかし、ここから<code class="language-plaintext highlighter-rouge">Task</code>とScala標準の<code class="language-plaintext highlighter-rouge">Future</code>との設計の違いが出てきます。
遅延という性格を持つ<code class="language-plaintext highlighter-rouge">Task</code>は、<code class="language-plaintext highlighter-rouge">runToFuture</code>を使った実行時にのみこの<code class="language-plaintext highlighter-rouge">Scheduler</code>を必要とし、Scalaの<code class="language-plaintext highlighter-rouge">Future</code>のようにすべての操作(<code class="language-plaintext highlighter-rouge">map</code>や<code class="language-plaintext highlighter-rouge">flatMap</code>など)で必要とされるわけではありません。</p>

<p>ではまず、スコープ内に<code class="language-plaintext highlighter-rouge">Scheduler</code>を用意しましょう。
この<code class="language-plaintext highlighter-rouge">global</code>は、Scala独自の<code class="language-plaintext highlighter-rouge">global</code>に乗っかっているので、次のようなことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
</code></pre></div></div>

<p><strong>注:</strong> <a href="/docs/current/execution/scheduler.html">Scheduler</a>は、非同期の境界がどのように強制されるか(あるいはされないか)を決定する設定可能な<a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a>を注入することができます。</p>

<p>最もわかりやすく慣用的な方法は、Taskを実行して<a href="/api/current/monix/execution/CancelableFuture.html">CancelableFuture</a>を返すことです。
これは、標準的な<code class="language-plaintext highlighter-rouge">Future</code>と<a href="/docs/current/execution/cancelable.html">Cancelable</a>を組み合わせたものです。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// 気が変わってキャンセルしたくなったら</span>
<span class="nv">result</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Future</code>を返すのが重すぎるのであれば、シンプルなコールバックを用意したほうがいいかもしれません。
標準の<code class="language-plaintext highlighter-rouge">Future.onComplete</code>と同様に、<code class="language-plaintext highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>コールバックを使って<code class="language-plaintext highlighter-rouge">runAsync</code>することもできます。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 気が変わってキャンセルしたくなったら...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>また、<a href="/docs/current/execution/callback.html">Callback</a>インスタンスを使って<code class="language-plaintext highlighter-rouge">runAsync</code>することもできます。
これはJava的なAPIのようなもので、状態を保持したい場合に便利です。
<code class="language-plaintext highlighter-rouge">Callback</code>は内部的にも使用されています。なぜなら契約違反を防ぎ、<code class="language-plaintext highlighter-rouge">Try[T]</code>や<code class="language-plaintext highlighter-rouge">Either[E, A]</code>に特有のボクシングを回避することができるからです。<br />
例:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Callback</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Callback</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">})</span>

<span class="c1">// 気が変わってキャンセルしたくなったら...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>しかし、いくつかの副作用を素早く発生させたい場合は、<code class="language-plaintext highlighter-rouge">foreach</code>を直接使うことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect!"</span><span class="o">);</span> <span class="s">"Result"</span> <span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect!</span>
<span class="c1">//=&gt; Result</span>

<span class="c1">// もしくはfor式も同様です</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">result</span> <span class="k">&lt;-</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>注: <code class="language-plaintext highlighter-rouge">Task</code>の<code class="language-plaintext highlighter-rouge">foreach</code>はブロックせずに<code class="language-plaintext highlighter-rouge">CancelableFuture[Unit]</code>を返します。これは任意に実行をブロックしたり、キャンセルするために使用できます。</p>
    
      <h3 id="結果をブロッキングする">
        
        
          結果をブロッキングする <a href="#結果をブロッキングする" class="anchor">#</a>
        
        
      </h3>

<p><a href="/docs/current/best-practices/blocking.html">Monixはその哲学としてブロッキングに反対</a>しており、したがって<code class="language-plaintext highlighter-rouge">Task</code>にはスレッドをブロックするAPIコールは一切ありません！</p>

<p>しかし、JVMの上では時にはブロックしなければならないこともあります。
なぜなら、標準の<code class="language-plaintext highlighter-rouge">Await.result</code>と<code class="language-plaintext highlighter-rouge">Await.ready</code>には、2つの健全な設計上の選択があるからです。</p>

<ol>
  <li>これらのコールは、Scalaの<code class="language-plaintext highlighter-rouge">BlockContext</code>を使って実装されています。
ブロッキング操作が実行されていることを基礎となるスレッドプールにシグナリングし、スレッドプールがそれに対応できるようにします。
例えばScalaの<code class="language-plaintext highlighter-rouge">ForkJoinPool</code>がやっているように、プールにスレッドを追加することを決めるかもしれません。</li>
  <li>これらの呼び出しには、非常に明示的なタイムアウト・パラメータが必要で、それは<code class="language-plaintext highlighter-rouge">FiniteDuration</code>として指定されます。</li>
</ol>

<p>したがって、まず <code class="language-plaintext highlighter-rouge">runToFuture</code>で結果を<code class="language-plaintext highlighter-rouge">Future</code>に変換してから、結果をブロックすることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">executeAsync</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="nv">Await</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p><strong>注:</strong> Scala.jsでは設計上、<a href="https://github.com/scala-js/scala-js/issues/186">ブロッキングはありません</a>。</p>
    
      <h3 id="即時実行を試みる">
        
        
          即時実行を試みる <a href="#即時実行を試みる" class="anchor">#</a>
        
        
      </h3>

<p>Monixはブロッキングに反対していることは確かです。
しかし、実行モデルで許可されていれば、現在の論理スレッドですぐに評価できる<code class="language-plaintext highlighter-rouge">Task</code>インスタンスもあることは明らかです。
そして<em>最適化のため</em>、コールバックの処理を避けて、その結果をすぐに実行したいと思うかもしれません。</p>

<p>そのためには、<code class="language-plaintext highlighter-rouge">runSyncStep</code>を使います:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runSyncStep</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">task</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// このTaskは非同期実行を強く望んでいるのでうまくいきません</span>
    <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Async: $r"</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got lucky: $result"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注:</strong> 偶然にも、<code class="language-plaintext highlighter-rouge">runSyncStep</code>のデフォルト評価は、基礎となるループで非同期の境界が強制されない限り、現在のスレッドで処理を実行します。
そのため、このコードは常に<em>GotLucky</em>と表示されます。 ;-)</p>
    
      <h2 id="シンプルなビルダー">
        
        
          シンプルなビルダー <a href="#シンプルなビルダー" class="anchor">#</a>
        
        
      </h2>

<p>非同期の可能性があるという性質を受け入れることができれば、<code class="language-plaintext highlighter-rouge">Task</code>は引数がない関数、Scalaの名前渡しパラメータ、<code class="language-plaintext highlighter-rouge">lazy val</code>を置き換えることができます。 また、Scala の <code class="language-plaintext highlighter-rouge">Future</code>はすべて <code class="language-plaintext highlighter-rouge">Task</code>に変換できます。</p>
    
      <h3 id="tasknow">
        
        
          Task.now <a href="#tasknow" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.now</code>は、<code class="language-plaintext highlighter-rouge">Task</code>コンテキストで既に知られている値をリフトします。
これは<code class="language-plaintext highlighter-rouge">Future.successful</code>や<code class="language-plaintext highlighter-rouge">Applicative.pure</code>に相当します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Now(Hello!))</span>
</code></pre></div></div>
    
      <h3 id="taskeval-遅延">
        
        
          Task.eval (遅延) <a href="#taskeval-遅延" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.eval</code>は、<code class="language-plaintext highlighter-rouge">Function0</code>と同等であり<code class="language-plaintext highlighter-rouge">runToFuture</code>で可能な限り同じスレッドで評価される関数を受け取ります(<a href="/docs/current/execution/scheduler.html#execution-model">選択された実行モデル</a>によります)。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Always(&lt;function0&gt;))</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// 評価(およびそれに伴うすべての副作用)は</span>
<span class="c1">// runToFutureごとに起動されます:</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: Scalazの場合、この関数は<code class="language-plaintext highlighter-rouge">Task.delay</code>と呼ばれています。</p>
    
      <h3 id="taskevalonce">
        
        
          Task.evalOnce <a href="#taskevalonce" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.evalOnce</code>は、Scalaでは正確に表現できない型である<code class="language-plaintext highlighter-rouge">lazy val</code>に相当します。
<code class="language-plaintext highlighter-rouge">evalOnce</code>ビルダーは最初の実行時にメモ化を行い、評価の結果を次の実行時にも利用できるようにします。
このビルダーは冪等性を保証し、スレッドセーフです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = EvalOnce(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// 結果は最初の実行でメモ化されました！</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: この操作は実質的に<code class="language-plaintext highlighter-rouge">Task.eval(f).memoize</code>です。</p>
    
      <h3 id="taskdefer-延期">
        
        
          Task.defer (延期) <a href="#taskdefer-延期" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.defer</code>は、Taskのファクトリを構築するためのものです。例えばこれは、<code class="language-plaintext highlighter-rouge">Task.eval</code>とほぼ同様の動作をします。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: Scalazの場合、この関数は<code class="language-plaintext highlighter-rouge">Task.suspend</code>という名前で呼ばれています。</p>
    
      <h3 id="taskfromfuture">
        
        
          Task.fromFuture <a href="#taskfromfuture" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.fromFuture</code>は、任意の<code class="language-plaintext highlighter-rouge">Future</code>インスタンスを<code class="language-plaintext highlighter-rouge">Task</code>に変換することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>なお、<code class="language-plaintext highlighter-rouge">fromFuture</code>は厳密な引数を取りますが、これはあなたが望むものではないかもしれません。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>は評価モデルを細かく制御することを目的としているので、ファクトリーが必要な場合は<code class="language-plaintext highlighter-rouge">Task.defer</code>と組み合わせる必要があります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; task: monix.eval.Task[Int] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfuture">
        
        
          Task.deferFuture <a href="#taskdeferfuture" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Future</code>の参照は厳密な値のようなもので、これを受け取るとそれを実行させるためのプロセスがすでに始まっていることになります。<br />
そのため、Taskを構築する際にFutureの評価を先送りすることに意味があります。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上記の近道として、<code class="language-plaintext highlighter-rouge">deferFuture</code>ビルダーを使うこともできます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span> <span class="o">{</span>
  <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfutureaction">
        
        
          Task.deferFutureAction <a href="#taskdeferfutureaction" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Future</code>の結果を生成するコールを<code class="language-plaintext highlighter-rouge">Task</code>にラップし、必要な<code class="language-plaintext highlighter-rouge">ExecutionContext</code>として動作する<code class="language-plaintext highlighter-rouge">Scheduler</code>を注入したコールバックを提供します。</p>

<p>このビルダーは、暗黙の<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を必要とする<code class="language-plaintext highlighter-rouge">Future</code>対応APIの使用に役立ちます。<br />
以下の例を考えてみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Future</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
</code></pre></div></div>

<p>この関数を、呼ばれるたびに和を評価する遅延型の<code class="language-plaintext highlighter-rouge">Task</code>を返す関数にしたいと思います。
Taskが最もよく機能する方法だからです。しかし、この関数を呼び出すためには<code class="language-plaintext highlighter-rouge">ExecutionContext</code>が必要です:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">))</span>
</code></pre></div></div>

<p>しかしこれは余計なお世話であるだけでなく、<code class="language-plaintext highlighter-rouge">Task</code>を使用するベストプラクティスに反しています。
その違いは、<code class="language-plaintext highlighter-rouge">Task</code>は<code class="language-plaintext highlighter-rouge">runToFuture</code>が呼ばれたときにのみ<code class="language-plaintext highlighter-rouge">Scheduler</code>(<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を継承したもの)を取るということです。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>の参照を構築するためだけにそれを必要とするわけではありません。
<code class="language-plaintext highlighter-rouge">DeferFutureAction</code>では、渡されたコールバックに<code class="language-plaintext highlighter-rouge">Scheduler</code>が注入されます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFutureAction</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">scheduler</span> <span class="k">=&gt;</span>
    <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Voilà!(ほらできました)。もう暗黙のパラメータ<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を渡す必要はありません。</p>
    
      <h3 id="taskexecuteasync-taskasyncboundary-taskexecuteon">
        
        
          Task.executeAsync, Task.asyncBoundary, Task.executeOn <a href="#taskexecuteasync-taskasyncboundary-taskexecuteon" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.executeAsync</code>は、実行時に(論理)スレッドのフォークを強制することで、非同期の境界を確保します。
時には本当に無駄なことをしていて、非同期の境界が発生することを保証したいことがあります。
デフォルトでは<a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a>は最初は現在のスレッドでの実行を好みます。</p>

<p>これにより、私たちのTaskが非同期に実行されることが保証されます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">executeAsync</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ExecuteOn</code>では、使用する代替の<code class="language-plaintext highlighter-rouge">Scheduler</code>を指定することができます。
つまり、<code class="language-plaintext highlighter-rouge">Task</code>の実行ループでは常に利用できる<code class="language-plaintext highlighter-rouge">Scheduler</code>が使用されますが、特定の操作では別のスケジューラに処理を振り分けたい場合があります。
例えば、ブロッキングI/O操作を別のスレッドプールで実行したい場合などです。</p>

<p>2つのスレッドプールがあるとします:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// デフォルトのScheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// I/Oに特化したSchedulerの作成</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="nv">io</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">io</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"my-io"</span><span class="o">)</span>
</code></pre></div></div>

<p>そして、何がどのように実行されるかを管理することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// デフォルトのSchedulerをforkで上書きする:</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Running on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">forked</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">executeOn</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>

<span class="nv">source</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-1</span>
<span class="nv">forked</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p>デフォルトの<code class="language-plaintext highlighter-rouge">Scheduler</code>で別の非同期境界がスケジューリングされない限り、最後に使用されたスケジューラー(スレッドプール)で実行されます。<br />
この組み合わせで何が起こるかというと:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-7</span>
<span class="c1">//=&gt; Running on thread: my-io-1</span>
<span class="c1">//=&gt; Ends on thread: my-io-1</span>
</code></pre></div></div>

<p>しかし、別の非同期バウンダリを挿入するとデフォルトに戻ります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">asyncBoundary</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span><span class="o">.</span><span class="py">executeAsync</span>
<span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">asyncBoundary</span><span class="o">)</span> <span class="c1">// switch back to global</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-5</span>
<span class="c1">//=&gt; Running on thread: my-io-2</span>
<span class="c1">//=&gt; Ends on thread: ForkJoinPool-1-worker-5</span>
</code></pre></div></div>

<p>しかし、<code class="language-plaintext highlighter-rouge">Task</code>にはこのようなトリックを手動で行わなくても、非同期境界を導入するための便利なメソッド<code class="language-plaintext highlighter-rouge">Task.asyncBoundary</code>があります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// globalで実行</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// ioで実行</span>
    <span class="o">.</span><span class="py">asyncBoundary</span> <span class="c1">// globalに戻す</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// globalで実行</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Schedulerのオーバーライドは一度しかできないことに注意してください。
<code class="language-plaintext highlighter-rouge">Task</code>インスタンスは不変なので、次のようにはなりません。
なぜなら、<code class="language-plaintext highlighter-rouge">forked</code>インスタンスでは<code class="language-plaintext highlighter-rouge">Scheduler</code>はすでに決まったものが設定されているからです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Trying to execute on global</span>
<span class="nv">forked</span><span class="o">.</span><span class="py">executeOn</span><span class="o">(</span><span class="n">global</span><span class="o">).</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p><strong>助言:</strong> ブロッキングI/Oを行っていない限り、デフォルトのスレッドプールを使い続けます。<code class="language-plaintext highlighter-rouge">global</code>が良いデフォルトです。
ブロッキングI/Oの場合は、2つ目のスレッドプールを使用しても問題ありません。しかし、それらのI/O操作を分離し、実際のI/O操作のためにのみスケジューラをオーバーライドします。</p>
    
      <h3 id="taskraiseerror">
        
        
          Task.raiseError <a href="#taskraiseerror" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.raiseError</code>は、<code class="language-plaintext highlighter-rouge">Task</code>のモナディックコンテキストでエラーをリフトすることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">error</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="c1">// error: monix.eval.Task[Int] =</span>
<span class="c1">//   Delay(Error(java.util.concurrent.TimeoutException))</span>

<span class="nv">error</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">))</span>
<span class="c1">//=&gt; Left(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="tasknever">
        
        
          Task.never <a href="#tasknever" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.never</code>は、決して完了しない<code class="language-plaintext highlighter-rouge">Task</code>インスタンスを返します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="c1">// 終了しないTaskインスタンス</span>
<span class="k">val</span> <span class="nv">never</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">never</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">))</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">// 3秒後:</span>
<span class="c1">// =&gt; Left(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>

<p>このインスタンスは共有されているので、ガベージコレクターのストレスを軽減することができます。</p>
    
      <h3 id="taskunit">
        
        
          Task.unit <a href="#taskunit" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.unit</code>は、すでに完了した<code class="language-plaintext highlighter-rouge">Task[Unit]</code>インスタンスを返します。
これはユーティリティとして提供されており、<code class="language-plaintext highlighter-rouge">Task.now(())</code>で新しいインスタンスを作成しなくて済むようになっています:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="c1">// task: monix.eval.Task[Unit] = Delay(Now(()))</span>
</code></pre></div></div>

<p>このインスタンスは共有されているので、ガベージコレクターのストレスを軽減することができます。</p>
    
      <h2 id="非同期型ビルダー">
        
        
          非同期型ビルダー <a href="#非同期型ビルダー" class="anchor">#</a>
        
        
      </h2>

<p>あらゆる非同期APIを使って、<code class="language-plaintext highlighter-rouge">Task</code>を作ることができます。
安全でないバージョンと、細かい処理を自動的に行うセーフバージョンがあります。
これは、細かい作業を自動的に処理するものです。</p>
    
      <h3 id="taskcreate">
        
        
          Task.create <a href="#taskcreate" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.create</code>は、Scalazをお使いならおなじみの<code class="language-plaintext highlighter-rouge">Task.async</code>と同じです。コールバックベースのAPIを使って非同期の<code class="language-plaintext highlighter-rouge">Task</code>を作成することができます。<br />
例えば、与えられた遅延時間で式を評価するユーティリティを作ってみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">def</span> <span class="nf">evalDelayed</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// 実行時にはスケジューラーとコールバックが注入されます ;-)</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span>
      <span class="nv">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">callback</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="c1">// 非同期の計算をキャンセルする次のようなものを返さなければなりません</span>
    <span class="n">cancelable</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>そして、<a href="#taskfromfuture">Task.fromFuture</a>を実装する場合の可能性として、以下のようなものを自分自身で実装します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nv">f</span><span class="o">.</span><span class="py">onComplete</span><span class="o">({</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
    <span class="o">})(</span><span class="n">scheduler</span><span class="o">)</span>

    <span class="c1">// ScalaのFutureたちはキャンセルできないので、</span>
    <span class="c1">// キャンセルできるかのように振る舞うべきではありません！</span>
    <span class="nv">Cancelable</span><span class="o">.</span><span class="py">empty</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>いくつかの注意点:</p>

<ul>
  <li>このビルダーで作成されたTaskは、非同期に(別の論理スレッドで)実行されることが保証されています。</li>
  <li><a href="/docs/current/execution/scheduler.html">Scheduler</a>が注入され、それによって非同期実行のために物事をスケジュールしたり、遅延させたりすることができます。</li>
  <li>しかし、前述のとおりこのコールバックはすでに非同期に実行されるので、用意された<code class="language-plaintext highlighter-rouge">Scheduler</code>で実行するように明示的にスケジュールする必要はありません。</li>
  <li><a href="/docs/current/execution/callback.html">コールバック</a>は実行時に注入され、そのコールバックには契約があります。
具体的には、<code class="language-plaintext highlighter-rouge">onSuccess</code>、<code class="language-plaintext highlighter-rouge">onError</code>、<code class="language-plaintext highlighter-rouge">apply</code>を一度だけ実行する必要があります。</li>
  <li>実行された処理が本当に時間内にキャンセルできない場合は、<code class="language-plaintext highlighter-rouge">Cancelable.empty</code>を返しても構いませんが、
できれば実行をキャンセルするような可能性があれば<code class="language-plaintext highlighter-rouge">Cancelable</code>を返すように努めるべきです。</li>
</ul>
    
      <h2 id="メモ化">
        
        
          メモ化 <a href="#メモ化" class="anchor">#</a>
        
        
      </h2>

<p><a href="/api/current/monix/eval/Task.html#memoize:monix.eval.Task[A]">Task#memoize</a>メソッドは、
任意の<code class="language-plaintext highlighter-rouge">Task</code>を受け取り、最初の<code class="language-plaintext highlighter-rouge">runToFuture</code>でメモ化を適用することができます:</p>

<ol>
  <li>冪等性が保証されている場合、<code class="language-plaintext highlighter-rouge">runToFuture</code>を複数回呼び出しても、1回呼び出したのと同じ効果が得られます。</li>
  <li>後続の<code class="language-plaintext highlighter-rouge">runToFuture</code>呼び出しは、最初の<code class="language-plaintext highlighter-rouge">runToFuture</code>で計算された結果を再利用します。</li>
</ol>

<p>つまり、<code class="language-plaintext highlighter-rouge">memoize</code>は、最初の<code class="language-plaintext highlighter-rouge">runToFuture</code>の結果を効果的にキャッシュするのです。<br />
実際にはこう言えます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="py">memoize</span>
</code></pre></div></div>

<p>これらは事実上同じで、<code class="language-plaintext highlighter-rouge">memoize</code>は以下のように動作します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 非同期実行で、.applyのセマンティクスを行う</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">memoized</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">memoize</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="成功したときだけメモ化する">
        
        
          成功したときだけメモ化する <a href="#成功したときだけメモ化する" class="anchor">#</a>
        
        
      </h3>

<p>時には、冪等性を保証した上で、成功した値だけをメモ化したい場合があります。
失敗した場合には 成功した値が得られるまで再試行したい場合があります。</p>

<p>そこで便利なのが<code class="language-plaintext highlighter-rouge">memoizeOnSuccess</code>メソッドです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">effect</span> <span class="k">=</span> <span class="mi">0</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span>
  <span class="n">effect</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">effect</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">)</span> <span class="k">else</span> <span class="n">effect</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cached</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">memoizeOnSuccess</span>

<span class="k">val</span> <span class="nv">f1</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// RuntimeException が生じる</span>
<span class="k">val</span> <span class="nv">f2</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// RuntimeException が生じる</span>
<span class="k">val</span> <span class="nv">f3</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// 3 になる</span>
<span class="k">val</span> <span class="nv">f4</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// 3 になる</span>
</code></pre></div></div>
    
      <h3 id="memoizeとruntofutureの比較">
        
        
          MemoizeとrunToFutureの比較 <a href="#memoizeとruntofutureの比較" class="anchor">#</a>
        
        
      </h3>

<p>次の例を見てみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
</code></pre></div></div>

<p>この<code class="language-plaintext highlighter-rouge">Future</code>インスタンスは、最初の<code class="language-plaintext highlighter-rouge">runToFuture</code>実行のメモ化された値で、他の<code class="language-plaintext highlighter-rouge">onComplete</code>サブスクライバで再利用できます。</p>

<p>この違いは、<code class="language-plaintext highlighter-rouge">Task</code>と<code class="language-plaintext highlighter-rouge">Future</code>の違いと同じです。
<code class="language-plaintext highlighter-rouge">memoize</code>の操作は遅延で、最初の<code class="language-plaintext highlighter-rouge">runToFuture</code>でのみ評価が行われます。
一方、<code class="language-plaintext highlighter-rouge">runToFuture</code>の結果は先行です。</p>
    
      <h2 id="操作">
        
        
          操作 <a href="#操作" class="anchor">#</a>
        
        
      </h2>
    
      <h3 id="flatmapと末尾再帰ループ">
        
        
          FlatMapと末尾再帰ループ <a href="#flatmapと末尾再帰ループ" class="anchor">#</a>
        
        
      </h3>

<p>まず、フィボナッチ数列のN番目の数を計算する簡単な例を見てみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="nd">@tailrec</span>
<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
 <span class="k">else</span>
   <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>これは末尾再帰的であることが必要で、そのためには<a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.tailrec">@tailrec</a>アノテーションを使用していますが，これはScalaの標準ライブラリにあります。
そして，もしこれを<code class="language-plaintext highlighter-rouge">Task</code>で記述すると、次のような実装が可能です:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span><span class="o">(</span><span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">))</span>
 <span class="k">else</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>そして今、すでに違いがあります。N番目のフィボナッチ数は、<code class="language-plaintext highlighter-rouge">runToFuture</code>するまで計算されないので、これは遅延です。
またこれはスタック(とヒープ)セーフなので、<code class="language-plaintext highlighter-rouge">@tailrec</code>アノテーションも必要ありません。</p>

<p><code class="language-plaintext highlighter-rouge">Task</code>は<code class="language-plaintext highlighter-rouge">flatMap</code>を持っており、これは単項演算の<code class="language-plaintext highlighter-rouge">bind</code>です。
これは、<code class="language-plaintext highlighter-rouge">Task</code>や<code class="language-plaintext highlighter-rouge">Future</code>のように、再帰性や順序付けを記述する操作です。(例：これを実行してからあれを実行して、あれを実行する)
そして、再帰的な呼び出しを記述するために使うことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span>
      <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>繰り返しになりますが、これはスタックセーフで一定量のメモリを使用します。<code class="language-plaintext highlighter-rouge">tailrec</code>アノテーションは必要ありません。
また、これは遅延な動作をします。なぜなら、<code class="language-plaintext highlighter-rouge">runToFuture</code>が発生するまで、何もトリガーされないからです。</p>

<p>でも、<strong>mutually tail-recursive calls</strong>を持つこともできます。w00t!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 相互末尾再帰, 最高!!!</span>
<span class="o">{</span>
  <span class="k">def</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="nf">even</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>繰り返しになりますが、これはスタックセーフで一定量のメモリを使用します。
そして何よりも <a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a>のおかげで、デフォルトではこれらのループは現在のスレッドを永遠にブロックしません。バッチでの実行を好みます。</p>
    
      <h3 id="並列性-catsparallel">
        
        
          並列性 (cats.Parallel) <a href="#並列性-catsparallel" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">flatMap</code>を使っていると、よくこんなことになってしまいます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// flatMapに基づく順序付け操作 ...</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">location</span> <span class="k">&lt;-</span> <span class="n">locationTask</span>
  <span class="n">phone</span> <span class="k">&lt;-</span> <span class="n">phoneTask</span>
  <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">addressTask</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ここでの問題は、これらの操作が順番に実行されるということです。
これはScalaの標準的な<code class="language-plaintext highlighter-rouge">Future</code>でも起こることで、時には望ましくない効果をもたらすこともありますが，<code class="language-plaintext highlighter-rouge">Task</code>は遅延的に評価されるためこの効果は<code class="language-plaintext highlighter-rouge">Task</code>でより顕著になります。</p>

<p>しかし、<code class="language-plaintext highlighter-rouge">Task</code>には<a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a>という実装があり、複数のTaskの評価を並行して行うことができます。
そのため、<code class="language-plaintext highlighter-rouge">parZip2</code>、<code class="language-plaintext highlighter-rouge">parZip3</code>などのユーティリティがあり、現在では<code class="language-plaintext highlighter-rouge">parZip6</code>まで実装されています。
上記の例は，次のように書くことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// 並行して実行される可能性がある </span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">parZip3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>タプルへのボックス化を避けるために、<code class="language-plaintext highlighter-rouge">parMap2</code>を使うこともできます。<br />
<code class="language-plaintext highlighter-rouge">parMap3</code>… <code class="language-plaintext highlighter-rouge">parMap6</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">parMap3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>また、<code class="language-plaintext highlighter-rouge">parMapN</code>にはCatsの構文が使えます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="py">parMapN</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a> も併せてご覧ください。</p>
    
      <h3 id="taskのシーケンスから結果を収集する">
        
        
          Taskのシーケンスから結果を収集する <a href="#taskのシーケンスから結果を収集する" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.sequence</code>は、<code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code>を取り、<code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>を返します。
このようにして、任意のTaskのシーケンスを順序付けられた効果と結果を持つTaskに変換します。
つまり、Taskが並列に実行されることはありません。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="c1">// 常に同じ順番になります:</span>
<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p>結果は初期シーケンスの順に並んでいるので、上の例ではまず<code class="language-plaintext highlighter-rouge">ta</code>(最初のTask)の結果が得られ、次に<code class="language-plaintext highlighter-rouge">tb</code>(2番目のTask)の結果が得られることが保証されていることになります。
また、実行自体にも順序があるので、<code class="language-plaintext highlighter-rouge">ta</code>が<code class="language-plaintext highlighter-rouge">tb</code>の前に実行され、完了します。</p>

<p><code class="language-plaintext highlighter-rouge">Task.parSequence</code>は、<code class="language-plaintext highlighter-rouge">Parallel.parSequence</code>と同様に、<code class="language-plaintext highlighter-rouge">Task.sequence</code>の非決定論的なバージョンです。
<code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code>を受け取り、<code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>を返すことで、Taskのシーケンスを順番に並べられた結果のシーケンスを持つTaskに変換します。
しかし、結果は順序付けられていません。つまり、並列実行の可能性があるということです。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.parSequenceUnordered</code>は<code class="language-plaintext highlighter-rouge">parSequence</code>と似ていますが、結果や効果の順序付けができないことを除けば，<code class="language-plaintext highlighter-rouge">parSequence</code>と同じです。
そのため結果は非常に非決定的ですが、<code class="language-plaintext highlighter-rouge">parSequence</code>よりも良いパフォーマンスが得られます。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">parSequenceUnordered</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Seq(2,1)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Seq(1,2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.traverse</code>は、<code class="language-plaintext highlighter-rouge">Seq[A]</code>, <code class="language-plaintext highlighter-rouge">f: A =&gt; Task[B]</code>を受け取り、<code class="language-plaintext highlighter-rouge">Task[Seq[B]]</code>を返します。
これは<code class="language-plaintext highlighter-rouge">Task.sequence</code>と似ていますが、<code class="language-plaintext highlighter-rouge">f</code>を使ってそれぞれの<code class="language-plaintext highlighter-rouge">Task</code>を生成します。</p>

<p>すべての<code class="language-plaintext highlighter-rouge">Task.sequence</code>セマンティクスは、効果が順序付けられていることを意味し、Taskは
並行して実行されることはありません。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="c1">// We always get this ordering:</span>
<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.parTraverse</code>は、<code class="language-plaintext highlighter-rouge">Parallel.parTraverse</code>と同様に<code class="language-plaintext highlighter-rouge">Task.traverse</code>の非決定論的バージョンです。
これもまた、<code class="language-plaintext highlighter-rouge">Seq[A]</code>, <code class="language-plaintext highlighter-rouge">f: A =&gt; Task[B]</code>を受け取り<code class="language-plaintext highlighter-rouge">Task[Seq[B]]</code>を返します。
シーケンスの各要素に<code class="language-plaintext highlighter-rouge">f</code>を適用して、それを<code class="language-plaintext highlighter-rouge">Task</code>に変換し、結果を収集します。
出力シーケンスの順序は維持されますが、並列実行の可能性があるということです。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parTraverse</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">parSequenceUnordered</code>と同様に、<code class="language-plaintext highlighter-rouge">parTraverse</code>の順序を保証しないバージョンである<code class="language-plaintext highlighter-rouge">parTraverseUnordered</code>もあります。</p>

<p><strong>注:</strong> 可能であればCats構文で提供されているメソッドではなく、明示的に<code class="language-plaintext highlighter-rouge">Task</code>のメソッドを使用することをお勧めします。
Catsのデフォルト実装は他のメソッドから派生したもので、最適化された<code class="language-plaintext highlighter-rouge">Task</code>バージョンよりもはるかに遅いことがよくあります。</p>

<p>以下に対応表を示します:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Monix</th>
      <th style="text-align: center">Cats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Task.sequence</td>
      <td style="text-align: center">Traverse[F].sequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.traverse</td>
      <td style="text-align: center">Traverse[F].traverse</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.parSequence</td>
      <td style="text-align: center">Parallel.parSequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.parTraverse</td>
      <td style="text-align: center">Parallel.parTraverse</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="race">
        
        
          Race <a href="#race" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">racePair</code>オペレーションは、2つの<code class="language-plaintext highlighter-rouge">Task</code>を並行して実行し、勝者を選びます。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">race</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">racePair</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">).</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fiber</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"A succeeded: $a"</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">fiber</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"B succeeded: $b"</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>生成される結果はタプルの<code class="language-plaintext highlighter-rouge">Either</code>で、レースに負けたもう一方のTaskに何かをする機会を与えてくれます。
そのTaskをキャンセルするか、その結果を何らかの形で利用するか、あるいは単に無視するかをユースケースによって選択できます。</p>
    
      <h3 id="race-many">
        
        
          Race Many <a href="#race-many" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">raceMany</code>オペレーションは、Taskのリストを入力として受け取ります。実行すると、最初のTaskが完了してレースに勝利した結果を生成します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>
    <span class="o">.</span><span class="py">runToFuture</span>
    <span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Winner: $r"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>これは、Scalaの<a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$@firstCompletedOf[T(futures:TraversableOnce[scala.concurrent.Future[T])(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[T]">Future.firstCompletedOf</a> に似ています。
<code class="language-plaintext highlighter-rouge">Task</code>を操作することを除いて、Taskがレースに勝つと他のTaskが即座にキャンセルされるので、より良いモデルになっています。</p>

<p>エラーを無視して、最初に成功した結果を待ちたい場合には<code class="language-plaintext highlighter-rouge">onErrorHandleWith</code>や<code class="language-plaintext highlighter-rouge">timeout</code>と組み合わせることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">timeout</span> <span class="k">=</span> <span class="mf">30.</span><span class="n">second</span>

<span class="k">val</span> <span class="nv">task1</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task2</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task3</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tasks</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">task1</span><span class="o">,</span> <span class="n">task2</span><span class="o">,</span> <span class="n">task3</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">))).</span><span class="py">timeout</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">result</span><span class="o">.</span><span class="py">runSyncUnsafe</span><span class="o">())</span> <span class="c1">// 10をプリントする</span>
</code></pre></div></div>
<p>これにより、失敗したTaskは非終了になります。</p>

<p>タイムアウトは、すべてのTaskが失敗した場合に必要です。上の例では、<code class="language-plaintext highlighter-rouge">task1</code>も失敗した場合、成功した結果が得られないことがわかっているにもかかわらず、タイムアウトが切れるのを待たなければなりません。</p>

<p>これを最適化するには、<code class="language-plaintext highlighter-rouge">Semaphore</code>を使った2回目の<code class="language-plaintext highlighter-rouge">race</code>を行う必要があります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.syntax.apply._</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task1</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task2</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task3</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tasks</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">task1</span><span class="o">,</span> <span class="n">task2</span><span class="o">,</span> <span class="n">task3</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">semaphore</span> <span class="k">=</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">Task</span><span class="o">](</span><span class="mi">0</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Unit</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">semaphore</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">sem</span> <span class="k">=&gt;</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">race</span><span class="o">(</span>
    <span class="nv">sem</span><span class="o">.</span><span class="py">acquireN</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">length</span><span class="o">),</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">sem</span><span class="o">.</span><span class="py">release</span> <span class="o">*&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">)))</span>
  <span class="o">)</span>
<span class="o">}</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">result</span><span class="o">.</span><span class="py">runSyncUnsafe</span><span class="o">())</span> <span class="c1">// 3秒後にプリントして終了する</span>
</code></pre></div></div>
    
      <h3 id="遅延実行">
        
        
          遅延実行 <a href="#遅延実行" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayExecution</code>は、その名のとおり与えられたTaskの実行を与えられた時間だけ遅らせます。</p>

<p>この例では、<code class="language-plaintext highlighter-rouge">source</code>の実行を3秒遅らせています:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="nv">delayed</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>また、遅延の代わりに、別の <code class="language-plaintext highlighter-rouge">Task</code>を実行開始のシグナルとして使用したい場合もあります。<br />
上の例と同じです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
  <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">source</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="結果の遅延シグナリング">
        
        
          結果の遅延シグナリング <a href="#結果の遅延シグナリング" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayResult</code>は結果の通知を遅らせますが、<code class="language-plaintext highlighter-rouge">Task</code>の実行は遅らせません。<br />
この例を考えてみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayResult</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">delayed</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>ここでは、<code class="language-plaintext highlighter-rouge">副作用はわずか1秒後に起こるが、結果の通知はさらに5秒後に起こる</code>ことがわかります。</p>
    
      <h3 id="述語が真になるまで再起動">
        
        
          述語が真になるまで再起動 <a href="#述語が真になるまで再起動" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>は仕様なので、自由に再起動することができます。<br />
<code class="language-plaintext highlighter-rouge">Task.restartUntil(predicate)</code>はまさに、述語が<code class="language-plaintext highlighter-rouge">true</code>になるまで何度も再実行します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>
    <span class="o">.</span><span class="py">restartUntil</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; -2097793116</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1246761488</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1053678416</span>
</code></pre></div></div>
    
      <h3 id="終了時にリソースをのクリーンアップ">
        
        
          終了時にリソースをのクリーンアップ <a href="#終了時にリソースをのクリーンアップ" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.doOnFinish</code>は、<code class="language-plaintext highlighter-rouge">Option[Throwable] =&gt; Task[Unit]</code>が終了したときに提供された関数を実行します。<br />
これはリソースのクリーンアップや予定されている副作用の実行を意味します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">withFinishCb</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">doOnFinish</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Was success!"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Had failure: $ex"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="o">}</span>

<span class="nv">withFinishCb</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Was success!</span>
<span class="c1">//=&gt; 1</span>
</code></pre></div></div>
    
      <h3 id="リアクティブパブリッシャーへの変換">
        
        
          リアクティブ・パブリッシャーへの変換 <a href="#リアクティブパブリッシャーへの変換" class="anchor">#</a>
        
        
      </h3>

<p>Monixが<a href="http://www.reactive-streams.org/">Reactive Streams</a>の仕様に統合されていることをご存知ですか？</p>

<p>さて、<code class="language-plaintext highlighter-rouge">Task</code>は<code class="language-plaintext highlighter-rouge">org.reactivestreams.Publisher</code>として見ることができます。サブスクリプション時に正確に1つのイベントを発行し、その後停止します。<br />
そして、私たちは任意の<code class="language-plaintext highlighter-rouge">Task</code>を直接そのようなパブリッシャーに変換することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>

<span class="k">val</span> <span class="nv">publisher</span><span class="k">:</span> <span class="kt">org.reactivestreams.Publisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">toReactivePublisher</span>
</code></pre></div></div>

<p>これは他のライブラリとの相互運用を目的としていますが、直接使いたい場合は少し低レベルです。<br />
でも可能です:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.reactivestreams._</span>

<span class="nv">publisher</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Subscriber</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Subscription</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">request</span><span class="o">(</span><span class="nv">Long</span><span class="o">.</span><span class="py">MaxValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"OnNext: $e"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"OnComplete"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: $ex"</span><span class="o">)</span>
<span class="o">})</span>

<span class="c1">// 次のようにプリントされる:</span>
<span class="c1">//=&gt; OnNext: -228329246</span>
<span class="c1">//=&gt; OnComplete</span>
</code></pre></div></div>

<p>凄いでしょう？</p>

<p>(◑‿◐)</p>
    
      <h2 id="エラーハンドリング">
        
        
          エラーハンドリング <a href="#エラーハンドリング" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Task</code>はエラー処理を非常に重要視しています。
ほら、<em>観察</em> についてこんな有名な話があるじゃないですか。<br />
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">思考実験</a>:</p>

<blockquote>
  <p>“<em>森の中で木が倒れても、周りにそれを聞く人がいなければ
その木は音を発しますか？</em>”</p>
</blockquote>

<p>これは、エラー処理に非常によく当てはまります。非同期プロセスでエラーが発生しても、それを聞く人がいなければキャッチしてログに残したり、回復したりすることはしません。
そして得られるのは<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">非決定論</a>のようなもので、エラーのヒントはありません。</p>

<p>Monixは常に発生したエラーをキャッチしてシグナルを送るか、少なくともログに記録します。
何らかの理由でシグナリングができない場合(コールバックがすでに呼び出されているなど)、ロギングは提供されている<code class="language-plaintext highlighter-rouge">Scheduler.reportFailure</code>を使って行われます。
SLF4Jを経由するなど、より具体的なものを提供しない限りはデフォルトで<code class="language-plaintext highlighter-rouge">System.err</code>となります。</p>

<p>Monixはそのメソッドに与えられる引数が<code class="language-plaintext highlighter-rouge">flatMap</code>のように純粋であるか、少なくともエラーから保護されていることを期待し、エラーをキャッチして<code class="language-plaintext highlighter-rouge">runAsync</code>でシグナルを送ります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">odd</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">odd</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Right(-924040280)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(java.lang.IllegalStateException: 834919637)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">runAsync</code>に提供されたコールバックでエラーが発生した場合、以下のようになります。
Monixはもはや<code class="language-plaintext highlighter-rouge">onError</code>のシグナルを出すことはできません。契約違反になるからです(<a href="/docs/current/execution/callback.html">Callback</a>を参照)。<br />
しかし、それはまだエラーを記録します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// 非同期の実行を保証</span>
<span class="c1">// 現在のスレッドではアクションは起こらない</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">r</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 1秒後に、スタックトレース全体をログに記録します:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: Right(2)</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt;	at monix.eval.Task$$anon$3.onSuccess(Task.scala:78)</span>
<span class="c1">//=&gt;	at monix.eval.Callback$SafeCallback.onSuccess(Callback.scala:66)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.trampoline$1(Task.scala:1248)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.monix$eval$Task$$resume(Task.scala:1304)</span>
<span class="c1">//=&gt;	at monix.eval.Task$AsyncStateRunnable$$anon$20.onSuccess(Task.scala:1432)</span>
<span class="c1">//=&gt;    ....</span>
</code></pre></div></div>

<p>同様に<code class="language-plaintext highlighter-rouge">Task.create</code>を使用した場合、Monixはエラーを捕捉しようとしますが、提供されたコールバックで何が起こったのかわからなかったため契約違反となるエラーを通知できません。(<a href="/docs/current/execution/callback.html">Callback</a>を参照) 
Monixは以下のようにエラーを記録します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">create</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"FTW!"</span><span class="o">))</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// 以下の内容をSystem.errに記録します:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: FTW!</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:576)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:571)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$AsyncStateRunnable.run(Task.scala:1429)</span>
<span class="c1">//=&gt;    ...</span>

<span class="c1">// このFutureは絶対に完了しません。うわー!</span>
<span class="nv">future</span><span class="o">.</span><span class="py">onComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><strong>警告:</strong> この場合、コンシューマーはシグナルを受け取ることはありません。
この話の教訓は、Monixが正しいことをするために最善の努力をしたとしても、特に<code class="language-plaintext highlighter-rouge">Task.create</code>では不要な例外からコードを保護すべきです!!!</p>
    
      <h3 id="エラーロギングのオーバーライド">
        
        
          エラーロギングのオーバーライド <a href="#エラーロギングのオーバーライド" class="anchor">#</a>
        
        
      </h3>

<p><a href="/docs/current/execution/scheduler.html">Scheduler</a>の記事には、独自のロジックで独自の<code class="language-plaintext highlighter-rouge">Scheduler</code>インスタンスを構築するためのレシピが掲載されています。
しかしここでは、そのような<code class="language-plaintext highlighter-rouge">Scheduler</code>を構築するための簡単なスニペットを紹介します。標準的な<a href="http://www.slf4j.org/">SLF4J</a>のようなライブラリを使って、ロギングを行います:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.</span><span class="o">{</span><span class="n">global</span> <span class="k">=&gt;</span> <span class="n">default</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.execution.UncaughtExceptionReporter</span>
<span class="k">import</span> <span class="nn">org.slf4j.LoggerFactory</span>

<span class="k">val</span> <span class="nv">reporter</span> <span class="k">=</span> <span class="nc">UncaughtExceptionReporter</span> <span class="o">{</span> <span class="n">ex</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">logger</span> <span class="k">=</span> <span class="nv">LoggerFactory</span><span class="o">.</span><span class="py">getLogger</span><span class="o">(</span><span class="s">"monix"</span><span class="o">)</span>
  <span class="nv">logger</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Uncaught exception"</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">global</span><span class="k">:</span> <span class="kt">Scheduler</span> <span class="o">=</span>
  <span class="nc">Scheduler</span><span class="o">(</span><span class="n">default</span><span class="o">,</span> <span class="n">reporter</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="タイムアウトのトリガー">
        
        
          タイムアウトのトリガー <a href="#タイムアウトのトリガー" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>の実行に時間がかかりすぎた場合には、<code class="language-plaintext highlighter-rouge">Task.timeout</code>を使って<code class="language-plaintext highlighter-rouge">TimeoutException</code>を発生させることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="c1">// runAsyncの後、3秒以内にソースが完了しないとエラーを起こす</span>
<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(TimeoutException)</span>
</code></pre></div></div>

<p>タイムアウトになると、ソースはキャンセルされます(キャンセルをサポートしているソースの場合)。
また、エラーの代わりに<code class="language-plaintext highlighter-rouge">fallback</code>タスクにタイムアウトすることもできます。
次の例は、上の例と同じです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span>
  <span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="エラーからの回復">
        
        
          エラーからの回復 <a href="#エラーからの回復" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code>は、起こりうる例外を望ましいフォールバックの結果に例外をマッピングする関数を取る操作です:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
    <span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// あぁ、タイムアウトのことを知ってるから回復するよ</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="c1">// 何が起こったのかわからないから、エラーを上げる！</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p>部分関数を受け取る<code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code>もあるので、<code class="language-plaintext highlighter-rouge">other</code>の部分を省略することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecoverWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// あぁ、タイムアウトのことを知ってるから回復するよ</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code>と<code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code>は、エラーの場合に限り<code class="language-plaintext highlighter-rouge">flatMap</code>に相当します。
フォールバックの結果を遅延で評価できることがわかっている場合には、ショートカットの操作<code class="language-plaintext highlighter-rouge">Task.onErrorHandle</code>を使用することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandle</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// あぁ、タイムアウトのことを知ってるから回復するよ</span>
    <span class="s">"Recovered!"</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="n">other</span> <span class="c1">// 再スロー</span>
<span class="o">}</span>
</code></pre></div></div>

<p>または、<code class="language-plaintext highlighter-rouge">onErrorRecover</code>を使った部分関数バージョン:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecover</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// あぁ、タイムアウトのことを知ってるから回復するよ</span>
    <span class="s">"Recovered!"</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="エラーのときに再起動する">
        
        
          エラーのときに再起動する <a href="#エラーのときに再起動する" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>タイプは単なる仕様であるため、通常は最終的な結果を得るためのあらゆるプロセスを再起動することができます。
また、エラーが発生した場合には必要な回数だけソースを再起動することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// 偶数のランダムな数字に対して4回リトライします</span>
<span class="c1">// またはmaxRetriesに達した場合は失敗します！</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestart</span><span class="o">(</span><span class="n">maxRetries</span> <span class="k">=</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>また、与えられた述語で再開することもできます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// IllegalStateExceptionが発生する限り、再試行を続けます</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestartIf</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">IllegalStateException</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></div></div>

<p>あるいは、指数関数的なバックオフによる独自のリトライを実装することもできます。<br />
そうするのがクールだからです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="c1">// 再帰呼び出しも、Monixはスタック・セーフなので問題なし</span>
        <span class="nf">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="エラーを公開する">
        
        
          エラーを公開する <a href="#エラーを公開する" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>のモナディックコンテキストは、Scalaの<code class="language-plaintext highlighter-rouge">Try</code>や<code class="language-plaintext highlighter-rouge">Future</code>のように発生したエラーを隠します。
しかし、時にはこれらのエラーを公開してより効率的に回復できるようにしたいこともあります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Try</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">materialized</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>

<span class="c1">// これで成功も失敗もフラットにできるようになりました:</span>
<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 0</span>
</code></pre></div></div>

<p>また、マテリアライズの逆もあり<code class="language-plaintext highlighter-rouge">Task.dematerialize</code>となります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="c1">// エラーを公開する</span>
<span class="k">val</span> <span class="nv">materialized</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>
<span class="c1">// materialize: Task[Try[Int]] = ???</span>

<span class="c1">// 再びエラーを隠す</span>
<span class="k">val</span> <span class="nv">dematerialized</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">dematerialize</span>
<span class="c1">// dematerialized: Task[Int] = ???</span>
</code></pre></div></div>

<p>また、任意の<code class="language-plaintext highlighter-rouge">Task</code>を<code class="language-plaintext highlighter-rouge">Task[Throwable]</code>に変換することもできます。
起こったエラーを公開したり、ソースが成功して完了した場合は<code class="language-plaintext highlighter-rouge">NoSuchElementException</code>で終了します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">throwable</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">failed</span>
<span class="c1">// throwable: Task[Throwable] = ???</span>

<span class="nv">throwable</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; java.lang.IllegalStateException</span>
</code></pre></div></div>


  <div class="buttons">
    <a href="/docs/current/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/eval/task.md">
      ページを編集</a> •
    
    <a href="https://gitter.im/monix/monix">
      チャットに参加</a> •
    <a href="/social.html">
      フォロー</a>
  </div>

  </div>
      </article>
    </div>
    <script type="text/javascript">
  var _paq = window._paq || [];
  // Disabling cookies for privacy reasons
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://ly.monix.io/";
    _paq.push(['setTrackerUrl', u+'m.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'m.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript>
  
  <img src="https://ly.monix.io/m.php?idsite=2&rec=1&action_name=Task" style="border:0" alt="" />
</noscript>


  </body>
</html>
