<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>Task &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/eval/task.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="Task &amp;mdash; Monix" />
  <meta name="twitter:description" content="A data type for controlling possibly lazy &amp;amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." />
  <meta name="twitter:url" content="https://monix.io/docs/current/eval/task.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="Task &amp;mdash; Monix" property="og:title">
  <meta content="A data type for controlling possibly lazy &amp;amp; asynchronous computations, useful for controlling side-effects, avoiding nondeterminism and callback-hell." property="og:description">
  <meta content="https://monix.io/docs/current/eval/task.html" property="og:url">
  <meta content="2021-06-30T15:09:19+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1625065946683260575">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1625065946683260575">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          Task
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2021-06-30">
    <b>ページの更新日:</b> 30 Jun 2021
  </time>
  <nav role="navigation" id="type-info">
    <a href="/api/current/monix/eval/Task.html">APIドキュメント</a>
    <a href="https://github.com/monix/monix/blob/v3.4.0/monix-eval/shared/src/main/scala/monix/eval/Task.scala">ソースコード</a>
    
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/eval/task.md">ページを編集</a>
    
  </nav>
  
  <div id="version3x">
    最新のMonix 3.xシリーズのドキュメントが表示されています。<br/>
    古いバージョン:
    
      <a href="/docs/2x/eval/task.html">2.x</a>
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#イントロダクション">イントロダクション</a>
    <ul>
      <li><a href="#設計の概要">設計の概要</a></li>
      <li><a href="#scalaのfutureとの比較">ScalaのFutureとの比較</a></li>
      <li><a href="#scalazのタスクとの比較">Scalazのタスクとの比較</a></li>
    </ul>
  </li>
  <li><a href="#実行-runtofuture--foreach">実行 (runToFuture &amp; foreach)</a>
    <ul>
      <li><a href="#結果をブロッキングする">結果をブロッキングする</a></li>
      <li><a href="#即時実行を試みる">即時実行を試みる</a></li>
    </ul>
  </li>
  <li><a href="#シンプルなビルダー">シンプルなビルダー</a>
    <ul>
      <li><a href="#tasknow">Task.now</a></li>
      <li><a href="#taskeval-遅延">Task.eval (遅延)</a></li>
      <li><a href="#taskevalonce">Task.evalOnce</a></li>
      <li><a href="#taskdefer-延期">Task.defer (延期)</a></li>
      <li><a href="#taskfromfuture">Task.fromFuture</a></li>
      <li><a href="#taskdeferfuture">Task.deferFuture</a></li>
      <li><a href="#taskdeferfutureaction">Task.deferFutureAction</a></li>
      <li><a href="#taskexecuteasync-taskasyncboundary-taskexecuteon">Task.executeAsync, Task.asyncBoundary, Task.executeOn</a></li>
      <li><a href="#taskraiseerror">Task.raiseError</a></li>
      <li><a href="#tasknever">Task.never</a></li>
      <li><a href="#taskunit">Task.unit</a></li>
    </ul>
  </li>
  <li><a href="#非同期型ビルダー">非同期型ビルダー</a>
    <ul>
      <li><a href="#taskcreate">Task.create</a></li>
    </ul>
  </li>
  <li><a href="#memoization">Memoization</a>
    <ul>
      <li><a href="#memoize-only-on-success">Memoize Only on Success</a></li>
      <li><a href="#memoize-versus-runtofuture">Memoize versus runToFuture</a></li>
    </ul>
  </li>
  <li><a href="#operations">Operations</a>
    <ul>
      <li><a href="#flatmap-and-tail-recursive-loops">FlatMap and Tail-Recursive Loops</a></li>
      <li><a href="#parallelism-catsparallel">Parallelism (cats.Parallel)</a></li>
      <li><a href="#gather-results-from-a-seq-of-tasks">Gather results from a Seq of Tasks</a></li>
      <li><a href="#race">Race</a></li>
      <li><a href="#race-many">Race Many</a></li>
      <li><a href="#delay-execution">Delay Execution</a></li>
      <li><a href="#delay-signaling-of-the-result">Delay Signaling of the Result</a></li>
      <li><a href="#restart-until-predicate-is-true">Restart Until Predicate is True</a></li>
      <li><a href="#clean-up-resources-on-finish">Clean-up Resources on Finish</a></li>
      <li><a href="#convert-to-reactive-publisher">Convert to Reactive Publisher</a></li>
    </ul>
  </li>
  <li><a href="#error-handling">Error Handling</a>
    <ul>
      <li><a href="#overriding-the-error-logging">Overriding the Error Logging</a></li>
      <li><a href="#trigger-a-timeout">Trigger a Timeout</a></li>
      <li><a href="#recovering-from-error">Recovering from Error</a></li>
      <li><a href="#restart-on-error">Restart On Error</a></li>
      <li><a href="#expose-errors">Expose Errors</a></li>
    </ul>
  </li>
</ul>

  </nav>
    
      <h2 id="イントロダクション">
        
        
          イントロダクション <a href="#イントロダクション" class="anchor">#</a>
        
        
      </h2>

<p>タスクは、遅延する可能性のある、非同期計算を制御するためのデータ型です。副作用の制御や非決定論やコールバック地獄の回避に役立ちます。</p>

<p>importを整理します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// タスクを評価するためには、Schedulerが必要です</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// キャンセル可能なFuture型</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>

<span class="c1">// Taskはmonix.eval内にあります</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sumを実行すると、(applyのセマンティクスにより)別のスレッドで発生します</span>
<span class="c1">// しかし、このインスタンスの構築時には何も起こりません</span>
<span class="c1">// この表現は純粋で、単なる仕様です。タスクはデフォルトでは遅延動作をします ;-)</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>

<span class="c1">// タスクはrunToFutureでのみ評価されます</span>
<span class="c1">// コールバックスタイル:</span>
<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">out</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//=&gt; 2</span>

<span class="c1">// または、Futureに変換することもできます</span>
<span class="k">val</span> <span class="nv">future</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// 結果を非同期にプリントします</span>
<span class="nv">future</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 2</span>
</code></pre></div></div>
    
      <h3 id="設計の概要">
        
        
          設計の概要 <a href="#設計の概要" class="anchor">#</a>
        
        
      </h3>

<p>Monixの <code class="language-plaintext highlighter-rouge">Task</code> を要約します:</p>

<ul>
  <li>遅延 &amp; 非同期評価</li>
  <li>1つのプロデューサーが1つまたは複数のコンシューマーに1つの値だけをプッシュするモデル</li>
  <li><a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a> をきめ細かく制御することができる</li>
  <li><code class="language-plaintext highlighter-rouge">runToFuture</code>が呼ばれるまでは、実行やその効果は引き起こされません</li>
  <li>必ずしも別の論理スレッドで実行する必要はありません</li>
  <li>実行中の計算をキャンセルすることができます</li>
  <li>Haskellの機能と同様に副作用を制御することができます(HaskellのI/Oと同じような効果があります)</li>
  <li>実装上、スレッドをブロックすることはありません</li>
  <li>スレッドをブロックするようなAPIコールを公開していません</li>
</ul>

<p>これらの仕様を表にまとめます:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">先行</th>
      <th style="text-align: center">遅延</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>同期</strong></td>
      <td style="text-align: center">A</td>
      <td style="text-align: center">() =&gt; A</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"><a href="/docs/current/eval/coeval.html">Coeval[A]</a></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>非同期</strong></td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
      <td style="text-align: center">(A =&gt; Unit) =&gt; Unit</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: center">Future[A]</td>
      <td style="text-align: center">Task[A]</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="scalaのfutureとの比較">
        
        
          ScalaのFutureとの比較 <a href="#scalaのfutureとの比較" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task</code>はScalaの <a href="http://docs.scala-lang.org/overviews/core/futures.html">Future</a> と似ていますが違った性格を持っており、この2つのタイプは実際には補完関係にあることがわかります。<br />
賢い人はかつてこう言いました。</p>

<blockquote>
  <p>“<em>未来は時間から切り離された価値を表す</em>” — Viktor Klang</p>
</blockquote>

<p>価値とは何か、時間とは何かを考えさせられる詩的な発想ですね。
しかし、より重要なことは、<code class="language-plaintext highlighter-rouge">Future</code>が <a href="https://en.wikipedia.org/wiki/Value_(computer_science)">値</a> であるとは言えないものの、<em>値になりたがっている</em> とは確実に言えるということです。
つまり、<code class="language-plaintext highlighter-rouge">Future</code>の参照を受け取ったとき、それを評価しようとしているどんなプロセスも、おそらくすでに始まっていて、またすでに終了しているかもしれません。
これにより、Scalaの<code class="language-plaintext highlighter-rouge">Future</code>の動作は <em>先行評価</em> となり、<code class="language-plaintext highlighter-rouge">map</code>や<code class="language-plaintext highlighter-rouge">flatMap</code>のような演算子を呼ぶときに、どのように暗黙の実行コンテキストを取るかを考えれば、確かにその設計は助けになります。</p>

<p>しかし、<code class="language-plaintext highlighter-rouge">Task</code>は違います。Taskは<code class="language-plaintext highlighter-rouge">遅延評価</code>です。実際、<code class="language-plaintext highlighter-rouge">Task</code>では実行モデルを微調整することができますが、これが両者の主な違いです。
<code class="language-plaintext highlighter-rouge">Future</code>が値のようなものなら、<code class="language-plaintext highlighter-rouge">Task</code>は関数のようなものです。そして実際に、<code class="language-plaintext highlighter-rouge">Task</code>は<code class="language-plaintext highlighter-rouge">Future</code>インスタンスの「ファクトリー」として機能します。</p>

<p>もうひとつの特徴は、<code class="language-plaintext highlighter-rouge">Future</code>はデフォルトで「<em>メモ化</em>される」ということです。
つまり、必要に応じて複数のコンシューマー間で共有されます。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>の評価は、デフォルトではメモ化されません。メモ化を実現するためには、明示的に指定しなければなりません。</p>

<p>先行評価の動作を持つ<code class="language-plaintext highlighter-rouge">Future</code>は、効率面で劣ります。
というのも、どのような操作を行っても実装は最終的にスレッドプールに<code class="language-plaintext highlighter-rouge">Runnable</code>インスタンスを送ることになり、結果が各ステップで常にメモ化されるからです。
一方、<code class="language-plaintext highlighter-rouge">Task</code>は同期的なバッチで実行することができます。</p>
    
      <h3 id="scalazのタスクとの比較">
        
        
          Scalazのタスクとの比較 <a href="#scalazのタスクとの比較" class="anchor">#</a>
        
        
      </h3>

<p>MonixのTaskが、<a href="https://github.com/scalaz/scalaz">Scalaz</a> のTaskにインスパイアされたことは周知の事実です。Monixライブラリ全体が巨人の肩の上に立っています。<br />
Monix Taskの実装が異なる点は:</p>

<ol>
  <li>ScalazのTaskは実装の詳細を漏らしています。
というのも、ScalazのTaskはまず<em>トランポリン</em>実行を目的としていますが、非同期実行は非同期のトランポリン境界を飛び越えることを目的としているからです。
例えば、大きなループで現在のスレッドをブロックしないようにするには、<code class="language-plaintext highlighter-rouge">Task.executeAsync</code>を使って非同期の境界を手動で挿入しなければなりません。
一方、MonixのTaskは、デフォルトで自動的にそれを行うようになっています。
これは、<a href="http://www.scala-js.org/">Javascript</a> の上で実行するときに非常に便利です。
<a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">協調的マルチタスク</a> はあったほうがいいだけでなく、必要なのです。</li>
  <li>ScalazのTaskは同期/非同期の2面を持っています。これは生産者にとっては最適化のために良いことです(例えば、必要がないのになぜスレッドをフォークするのか)。
しかし、コンシューマの視点から見ると、<code class="language-plaintext highlighter-rouge">def run: A</code>は、JavascriptやJVM上でAPIを完全にサポートできないことを意味します。
つまり、Scalazの<code class="language-plaintext highlighter-rouge">Task</code> は結局、同期評価やスレッドのブロックを偽装することになるのです。
そして、<a href="/docs/current/best-practices/blocking.html">スレッドをブロックすることは非常に安全ではありません</a></li>
  <li>ScalazのTaskは、実行中の計算をキャンセルすることはできません。これは非決定論的な操作では重要です。
例えば、<code class="language-plaintext highlighter-rouge">race</code>で競合状態を作ったときに、時間内に終わらなかった遅いタスクをキャンセルしたい場合があります。
というのもリソースをすぐに解放しないと、残念ながら深刻なリークが発生してプロセスがクラッシュしてしまうことがあるからです。</li>
  <li>Scalazタスクは、非同期実行を扱うJavaの標準ライブラリを利用しています。
これはポータビリティの観点からは好ましくありません。このAPIは<a href="http://www.scala-js.org/">Scala.js</a> の上ではサポートされていないからです。</li>
</ol>
    
      <h2 id="実行-runtofuture--foreach">
        
        
          実行 (runToFuture &amp; foreach) <a href="#実行-runtofuture--foreach" class="anchor">#</a>
        
        
      </h2>

<p>Taskインスタンスは、<code class="language-plaintext highlighter-rouge">runToFuture</code>によって実行されるまで何もしません。また、複数のオーバーロードがあります。</p>

<p><code class="language-plaintext highlighter-rouge">Task.runToFuture</code>では<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を継承した<a href="/docs/current/execution/scheduler.html">Scheduler</a> を暗黙のパラメータとして求められます。
しかし、ここから<code class="language-plaintext highlighter-rouge">Task</code>とScala標準の<code class="language-plaintext highlighter-rouge">Future</code>との設計の違いが出てきます。
遅延という性格を持つ<code class="language-plaintext highlighter-rouge">Task</code>は、<code class="language-plaintext highlighter-rouge">runToFuture</code>を使った実行時にのみこの<code class="language-plaintext highlighter-rouge">Scheduler</code>を必要とし、Scalaの<code class="language-plaintext highlighter-rouge">Future</code>のようにすべての操作(<code class="language-plaintext highlighter-rouge">map</code>や<code class="language-plaintext highlighter-rouge">flatMap</code>など)で必要とされるわけではありません。</p>

<p>ではまず、スコープ内に<code class="language-plaintext highlighter-rouge">Scheduler</code>を用意しましょう。
この<code class="language-plaintext highlighter-rouge">global</code>は、Scala独自の<code class="language-plaintext highlighter-rouge">global</code>に乗っかっているので、次のようなことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
</code></pre></div></div>

<p><strong>注:</strong> <a href="/docs/current/execution/scheduler.html">Scheduler</a> は、非同期の境界がどのように強制されるか(あるいはされないか)を決定する設定可能な<a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a> を注入することができます。</p>

<p>最もわかりやすく慣用的な方法は、タスクを実行して<a href="/api/current/monix/execution/CancelableFuture.html">CancelableFuture</a> を返すことです。
これは、標準的な<code class="language-plaintext highlighter-rouge">Future</code>と<a href="/docs/current/execution/cancelable.html">Cancelable</a> を組み合わせたものです。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.CancelableFuture</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">CancelableFuture</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// 気が変わってキャンセルしたくなったら</span>
<span class="nv">result</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Future</code>を返すのが重すぎるのであれば、シンプルなコールバックを用意したほうがいいかもしれません。
標準の<code class="language-plaintext highlighter-rouge">Future.onComplete</code>と同様に、<code class="language-plaintext highlighter-rouge">Either[Throwable, A] =&gt; Unit</code>コールバックを使って<code class="language-plaintext highlighter-rouge">runAsync</code>することもできます。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
  <span class="n">result</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 気が変わってキャンセルしたくなったら...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>また、<a href="/docs/current/execution/callback.html">Callback</a> インスタンスを使って<code class="language-plaintext highlighter-rouge">runAsync</code>することもできます。
これはJava的なAPIのようなもので、状態を保持したい場合に便利です。
<code class="language-plaintext highlighter-rouge">Callback</code>は内部的にも使用されています。なぜなら契約違反を防ぎ、<code class="language-plaintext highlighter-rouge">Try[T]</code>や<code class="language-plaintext highlighter-rouge">Either[E, A]</code>に特有のボクシングを回避することができるからです。<br />
例:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Callback</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Callback</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nf">println</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
    <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: ${ex.getMessage}"</span><span class="o">)</span>
  <span class="o">})</span>

<span class="c1">// 気が変わってキャンセルしたくなったら...</span>
<span class="nv">cancelable</span><span class="o">.</span><span class="py">cancel</span><span class="o">()</span>
</code></pre></div></div>

<p>しかし、いくつかの副作用を素早く発生させたい場合は、<code class="language-plaintext highlighter-rouge">foreach</code>を直接使うことができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect!"</span><span class="o">);</span> <span class="s">"Result"</span> <span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect!</span>
<span class="c1">//=&gt; Result</span>

<span class="c1">// もしくはfor式も同様です</span>
<span class="nf">for</span> <span class="o">(</span><span class="n">result</span> <span class="k">&lt;-</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>注: <code class="language-plaintext highlighter-rouge">Task</code>の<code class="language-plaintext highlighter-rouge">foreach</code>はブロックせずに<code class="language-plaintext highlighter-rouge">CancelableFuture[Unit]</code>を返します。これは任意に実行をブロックしたり、キャンセルするために使用できます。</p>
    
      <h3 id="結果をブロッキングする">
        
        
          結果をブロッキングする <a href="#結果をブロッキングする" class="anchor">#</a>
        
        
      </h3>

<p><a href="/docs/current/best-practices/blocking.html">Monixはその哲学としてブロッキングに反対</a> しており、したがって<code class="language-plaintext highlighter-rouge">Task</code>にはスレッドをブロックするAPIコールは一切ありません！</p>

<p>しかし、JVMの上では時にはブロックしなければならないこともあります。
なぜなら、標準の<code class="language-plaintext highlighter-rouge">Await.result</code>と<code class="language-plaintext highlighter-rouge">Await.ready</code>には、2つの健全な設計上の選択があるからです。</p>

<ol>
  <li>これらのコールは、Scalaの<code class="language-plaintext highlighter-rouge">BlockContext</code>を使って実装されています。
ブロッキング操作が実行されていることを基礎となるスレッドプールにシグナリングし、スレッドプールがそれに対応できるようにします。
例えばScalaの<code class="language-plaintext highlighter-rouge">ForkJoinPool</code>がやっているように、プールにスレッドを追加することを決めるかもしれません。</li>
  <li>これらの呼び出しには、非常に明示的なタイムアウト・パラメータが必要で、それは<code class="language-plaintext highlighter-rouge">FiniteDuration</code>として指定されます。</li>
</ol>

<p>したがって、まず <code class="language-plaintext highlighter-rouge">runToFuture</code>で結果を<code class="language-plaintext highlighter-rouge">Future</code> に変換してから、結果をブロックすることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">executeAsync</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="nv">Await</span><span class="o">.</span><span class="py">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p><strong>注:</strong> Scala.jsでは設計上、<a href="https://github.com/scala-js/scala-js/issues/186">ブロッキングはありません</a>。</p>
    
      <h3 id="即時実行を試みる">
        
        
          即時実行を試みる <a href="#即時実行を試みる" class="anchor">#</a>
        
        
      </h3>

<p>Monixはブロッキングに反対していることは確かです。
しかし、実行モデルで許可されていれば、現在の論理スレッドですぐに評価できる<code class="language-plaintext highlighter-rouge">Task</code>インスタンスもあることは明らかです。
そして<em>最適化のため</em>、コールバックの処理を避けて、その結果をすぐに実行したいと思うかもしれません。</p>

<p>そのためには、<code class="language-plaintext highlighter-rouge">runSyncStep</code>を使います:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runSyncStep</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">task</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="c1">// このタスクは非同期実行を強く望んでいるのでうまくいきません</span>
    <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Async: $r"</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Got lucky: $result"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注:</strong> 偶然にも、<code class="language-plaintext highlighter-rouge">runSyncStep</code>のデフォルト評価は、基礎となるループで非同期の境界が強制されない限り、現在のスレッドで処理を実行します。
そのため、このコードは常に<em>GotLucky</em>と表示されます。 ;-)</p>
    
      <h2 id="シンプルなビルダー">
        
        
          シンプルなビルダー <a href="#シンプルなビルダー" class="anchor">#</a>
        
        
      </h2>

<p>非同期の可能性があるという性質を受け入れることができれば、<code class="language-plaintext highlighter-rouge">Task</code>は引数がない関数、Scalaの名前渡しパラメータ、<code class="language-plaintext highlighter-rouge">lazy val</code>を置き換えることができます。 また、Scala の <code class="language-plaintext highlighter-rouge">Future</code> はすべて <code class="language-plaintext highlighter-rouge">Task</code> に変換できます。</p>
    
      <h3 id="tasknow">
        
        
          Task.now <a href="#tasknow" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.now</code>は、<code class="language-plaintext highlighter-rouge">Task</code>コンテキストで既に知られている値をリフトします。
これは<code class="language-plaintext highlighter-rouge">Future.successful</code>や<code class="language-plaintext highlighter-rouge">Applicative.pure</code>に相当します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Now(Hello!))</span>
</code></pre></div></div>
    
      <h3 id="taskeval-遅延">
        
        
          Task.eval (遅延) <a href="#taskeval-遅延" class="anchor">#</a>
        
        
      </h3>

<p>Task.eval<code class="language-plaintext highlighter-rouge">は、</code>Function0<code class="language-plaintext highlighter-rouge">と同等であり</code>runToFuture`で可能な限り同じスレッドで評価される関数を受け取ります(<a href="/docs/current/execution/scheduler.html#execution-model">選択された実行モデル</a> によります)。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Delay(Always(&lt;function0&gt;))</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// 評価(およびそれに伴うすべての副作用)は</span>
<span class="c1">// runToFutureごとに起動されます:</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: Scalazの場合、この関数は<code class="language-plaintext highlighter-rouge">Task.delay</code>と呼ばれています。</p>
    
      <h3 id="taskevalonce">
        
        
          Task.evalOnce <a href="#taskevalonce" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.evalOnce</code> は、Scalaでは正確に表現できない型である「lazy val」に相当します。
<code class="language-plaintext highlighter-rouge">evalOnce</code>ビルダーは最初の実行時にメモ化を行い、評価の結果を次の実行時にも利用できるようにします。
このビルダーは冪等性を保証し、スレッドセーフです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = EvalOnce(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="c1">// 結果は最初の実行でメモ化されました！</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: この操作は実質的に<code class="language-plaintext highlighter-rouge">Task.eval(f).memoize</code>です。</p>
    
      <h3 id="taskdefer-延期">
        
        
          Task.defer (延期) <a href="#taskdefer-延期" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.defer</code> は、タスクのファクトリを構築するためのものです。例えばこれは、<code class="language-plaintext highlighter-rouge">Task.eval</code>とほぼ同様の動作をします。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">now</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// task: monix.eval.Task[String] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>注: Scalazの場合、この関数は<code class="language-plaintext highlighter-rouge">Task.suspend</code>という名前で呼ばれています。</p>
    
      <h3 id="taskfromfuture">
        
        
          Task.fromFuture <a href="#taskfromfuture" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.fromFuture</code>は、任意の<code class="language-plaintext highlighter-rouge">Future</code>インスタンスを<code class="language-plaintext highlighter-rouge">Task</code>に変換することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>

<p>なお、<code class="language-plaintext highlighter-rouge">fromFuture</code>は厳密な引数を取りますが、これはあなたが望むものではないかもしれません。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>は評価モデルを細かく制御することを目的としているので、ファクトリーが必要な場合は<code class="language-plaintext highlighter-rouge">Task.defer</code>と組み合わせる必要があります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">//=&gt; task: monix.eval.Task[Int] = Suspend(&lt;function0&gt;)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfuture">
        
        
          Task.deferFuture <a href="#taskdeferfuture" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Future</code>の参照は厳密な値のようなもので、これを受け取るとそれを実行させるためのプロセスがすでに始まっていることになります。<br />
そのため、Taskを構築する際にFutureの評価を先送りすることに意味があります。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">fromFuture</span><span class="o">(</span><span class="n">future</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上記の近道として、<code class="language-plaintext highlighter-rouge">deferFuture</code>ビルダーを使うこともできます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span> <span class="o">{</span>
  <span class="nc">Future</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="taskdeferfutureaction">
        
        
          Task.deferFutureAction <a href="#taskdeferfutureaction" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Future</code> の結果を生成するコールを<code class="language-plaintext highlighter-rouge">Task</code>にラップし、必要な<code class="language-plaintext highlighter-rouge">ExecutionContext</code>として動作する<code class="language-plaintext highlighter-rouge">Scheduler</code>を注入したコールバックを提供します。</p>

<p>このビルダーは、暗黙の<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を必要とする<code class="language-plaintext highlighter-rouge">Future</code>対応APIの使用に役立ちます。<br />
以下の例を考えてみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.</span><span class="o">{</span><span class="nc">ExecutionContext</span><span class="o">,</span> <span class="nc">Future</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Future</span><span class="o">(</span><span class="nv">list</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
</code></pre></div></div>

<p>この関数を、呼ばれるたびに和を評価する遅延型の<code class="language-plaintext highlighter-rouge">Task</code>を返す関数にしたいと思います。
Taskが最もよく機能する方法だからです。しかし、この関数を呼び出すためには<code class="language-plaintext highlighter-rouge">ExecutionContext</code>が必要です:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ec</span><span class="k">:</span> <span class="kt">ExecutionContext</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFuture</span><span class="o">(</span><span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">))</span>
</code></pre></div></div>

<p>しかしこれは余計なお世話であるだけでなく、<code class="language-plaintext highlighter-rouge">Task</code>を使用するベストプラクティスに反しています。
その違いは、<code class="language-plaintext highlighter-rouge">Task</code> は<code class="language-plaintext highlighter-rouge">runToFuture</code>が呼ばれたときにのみ<code class="language-plaintext highlighter-rouge">Scheduler</code>(<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を継承したもの) を取るということです。
しかし、<code class="language-plaintext highlighter-rouge">Task</code>の参照を構築するためだけにそれを必要とするわけではありません。
<code class="language-plaintext highlighter-rouge">DeferFutureAction</code>では、渡されたコールバックに<code class="language-plaintext highlighter-rouge">Scheduler</code>が注入されます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sumTask</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">deferFutureAction</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">scheduler</span> <span class="k">=&gt;</span>
    <span class="nf">sumFuture</span><span class="o">(</span><span class="n">list</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Voilà!(ほらできました)。もう暗黙のパラメータ<code class="language-plaintext highlighter-rouge">ExecutionContext</code>を渡す必要はありません。</p>
    
      <h3 id="taskexecuteasync-taskasyncboundary-taskexecuteon">
        
        
          Task.executeAsync, Task.asyncBoundary, Task.executeOn <a href="#taskexecuteasync-taskasyncboundary-taskexecuteon" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.executeAsync</code>は、実行時に(論理)スレッドのフォークを強制することで、非同期の境界を確保します。
時には本当に無駄なことをしていて、非同期の境界が発生することを保証したいことがあります。
デフォルトでは<a href="/docs/current/execution/scheduler.html#execution-model">実行モデル</a> は最初は現在のスレッドでの実行を好みます。</p>

<p>これにより、私たちのタスクが非同期に実行されることが保証されます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">executeAsync</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ExecuteOn</code>では、使用する代替の<code class="language-plaintext highlighter-rouge">Scheduler</code>を指定することができます。
つまり、<code class="language-plaintext highlighter-rouge">Task</code> の実行ループでは常に利用できる<code class="language-plaintext highlighter-rouge">Scheduler</code>が使用されますが、特定の操作では別のスケジューラに処理を振り分けたい場合があります。
例えば、ブロッキングI/O操作を別のスレッドプールで実行したい場合などです。</p>

<p>2つのスレッドプールがあるとします:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// デフォルトのScheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>

<span class="c1">// I/Oに特化したSchedulerの作成</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="nv">io</span> <span class="k">=</span> <span class="nv">Scheduler</span><span class="o">.</span><span class="py">io</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"my-io"</span><span class="o">)</span>
</code></pre></div></div>

<p>そして、何がどのように実行されるかを管理することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// デフォルトのSchedulerをforkで上書きする:</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Running on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">forked</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">executeOn</span><span class="o">(</span><span class="n">io</span><span class="o">)</span>

<span class="nv">source</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-1</span>
<span class="nv">forked</span><span class="o">.</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p>デフォルトの<code class="language-plaintext highlighter-rouge">Scheduler</code>で別の非同期境界がスケジューリングされない限り、最後に使用されたスケジューラー(スレッドプール)で実行されます。<br />
この組み合わせで何が起こるかというと:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-7</span>
<span class="c1">//=&gt; Running on thread: my-io-1</span>
<span class="c1">//=&gt; Ends on thread: my-io-1</span>
</code></pre></div></div>

<p>しかし、別の非同期バウンダリを挿入するとデフォルトに戻ります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">asyncBoundary</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span><span class="o">.</span><span class="py">executeAsync</span>
<span class="k">val</span> <span class="nv">onFinish</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span>
  <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Ends on thread: ${Thread.currentThread.getName}"</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// executes on io</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">asyncBoundary</span><span class="o">)</span> <span class="c1">// switch back to global</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// executes on global</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>

<span class="c1">//=&gt; Running on thread: ForkJoinPool-1-worker-5</span>
<span class="c1">//=&gt; Running on thread: my-io-2</span>
<span class="c1">//=&gt; Ends on thread: ForkJoinPool-1-worker-5</span>
</code></pre></div></div>

<p>しかし、<code class="language-plaintext highlighter-rouge">Task</code>にはこのようなトリックを手動で行わなくても、非同期境界を導入するための便利なメソッド<code class="language-plaintext highlighter-rouge">Task.asyncBoundary</code>があります:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span> <span class="c1">// globalで実行</span>
    <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">forked</span><span class="o">)</span> <span class="c1">// ioで実行</span>
    <span class="o">.</span><span class="py">asyncBoundary</span> <span class="c1">// globalに戻す</span>
    <span class="o">.</span><span class="py">doOnFinish</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">onFinish</span><span class="o">)</span> <span class="c1">// globalで実行</span>
    <span class="o">.</span><span class="py">runToFuture</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Schedulerのオーバーライドは一度しかできないことに注意してください。
<code class="language-plaintext highlighter-rouge">Task</code>インスタンスは不変なので、次のようにはなりません。
なぜなら、<code class="language-plaintext highlighter-rouge">forked</code>インスタンスでは<code class="language-plaintext highlighter-rouge">Scheduler</code>はすでに決まったものが設定されているからです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Trying to execute on global</span>
<span class="nv">forked</span><span class="o">.</span><span class="py">executeOn</span><span class="o">(</span><span class="n">global</span><span class="o">).</span><span class="py">runToFuture</span>
<span class="c1">//=&gt; Running on thread: my-io-4</span>
</code></pre></div></div>

<p><strong>助言:</strong> ブロッキングI/Oを行っていない限り、デフォルトのスレッドプールを使い続けます。<code class="language-plaintext highlighter-rouge">global</code>が良いデフォルトです。
ブロッキングI/Oの場合は、2つ目のスレッドプールを使用しても問題ありません。しかし、それらのI/O操作を分離し、実際のI/O操作のためにのみスケジューラをオーバーライドします。</p>
    
      <h3 id="taskraiseerror">
        
        
          Task.raiseError <a href="#taskraiseerror" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.raiseError</code>は、<code class="language-plaintext highlighter-rouge">Task</code>のモナディックコンテキストでエラーをリフトすることができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">error</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="c1">// error: monix.eval.Task[Int] =</span>
<span class="c1">//   Delay(Error(java.util.concurrent.TimeoutException))</span>

<span class="nv">error</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">result</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">result</span><span class="o">))</span>
<span class="c1">//=&gt; Left(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="tasknever">
        
        
          Task.never <a href="#tasknever" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.never</code> は、決して完了しない<code class="language-plaintext highlighter-rouge">Task</code>インスタンスを返します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="c1">// 終了しないTaskインスタンス</span>
<span class="k">val</span> <span class="nv">never</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">never</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">))</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">// 3秒後:</span>
<span class="c1">// =&gt; Left(java.util.concurrent.TimeoutException)</span>
</code></pre></div></div>

<p>このインスタンスは共有されているので、ガベージコレクターのストレスを軽減することができます。</p>
    
      <h3 id="taskunit">
        
        
          Task.unit <a href="#taskunit" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.unit</code>は、すでに完了した<code class="language-plaintext highlighter-rouge">Task[Unit]</code>インスタンスを返します。
これはユーティリティとして提供されており、<code class="language-plaintext highlighter-rouge">Task.now(())</code>で新しいインスタンスを作成しなくて済むようになっています:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="c1">// task: monix.eval.Task[Unit] = Delay(Now(()))</span>
</code></pre></div></div>

<p>このインスタンスは共有されているので、ガベージコレクターのストレスを軽減することができます。</p>
    
      <h2 id="非同期型ビルダー">
        
        
          非同期型ビルダー <a href="#非同期型ビルダー" class="anchor">#</a>
        
        
      </h2>

<p>あらゆる非同期APIを使って、<code class="language-plaintext highlighter-rouge">Task</code>を作ることができます。
安全でないバージョンと、細かい処理を自動的に行うセーフバージョンがあります。
これは、細かい作業を自動的に処理するものです。</p>
    
      <h3 id="taskcreate">
        
        
          Task.create <a href="#taskcreate" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.create</code>は、Scalazをお使いならおなじみの<code class="language-plaintext highlighter-rouge">Task.async</code>と同じです。コールバックベースのAPIを使って非同期の<code class="language-plaintext highlighter-rouge">Task</code>を作成することができます。<br />
例えば、与えられた遅延時間で式を評価するユーティリティを作ってみましょう:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>
<span class="k">import</span> <span class="nn">concurrent.duration._</span>

<span class="k">def</span> <span class="nf">evalDelayed</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">delay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span>
  <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="c1">// 実行時にはスケジューラーとコールバックが注入されます ;-)</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="nv">cancelable</span> <span class="k">=</span>
      <span class="nv">scheduler</span><span class="o">.</span><span class="py">scheduleOnce</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span>
        <span class="nf">callback</span><span class="o">(</span><span class="nc">Try</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
      <span class="o">}</span>

    <span class="c1">// 非同期の計算をキャンセルする次のようなものを返さなければなりません</span>
    <span class="n">cancelable</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>そして、<a href="#taskfromfuture">Task.fromFuture</a> を実装する場合の可能性として、以下のようなものを自分自身で実装します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Cancelable</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">def</span> <span class="nf">fromFuture</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">create</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nv">f</span><span class="o">.</span><span class="py">onComplete</span><span class="o">({</span>
      <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nv">callback</span><span class="o">.</span><span class="py">onError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
    <span class="o">})(</span><span class="n">scheduler</span><span class="o">)</span>

    <span class="c1">// ScalaのFutureたちはキャンセルできないので、</span>
    <span class="c1">// キャンセルできるかのように振る舞うべきではありません！</span>
    <span class="nv">Cancelable</span><span class="o">.</span><span class="py">empty</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>いくつかの注意点:</p>

<ul>
  <li>Tasks created with this builder are guaranteed to execute
asynchronously (on another logical thread)</li>
  <li>The <a href="/docs/current/execution/scheduler.html">Scheduler</a> gets injected and with
it we can schedule things for async execution, we can delay,
etc…</li>
  <li>But as said, this callback will already execute asynchronously, so
you don’t need to explicitly schedule things to run on the provided
<code class="language-plaintext highlighter-rouge">Scheduler</code>, unless you really need to do it.</li>
  <li><a href="/docs/current/execution/callback.html">The Callback</a> gets injected on execution and that
callback has a contract. In particular you need to execute
<code class="language-plaintext highlighter-rouge">onSuccess</code> or <code class="language-plaintext highlighter-rouge">onError</code> or <code class="language-plaintext highlighter-rouge">apply</code> only once. The implementation
does a reasonably good job to protect against contract violations,
but if you do call it multiple times, then you’re doing it risking
undefined and nondeterministic behavior.</li>
  <li>It’s OK to return a <code class="language-plaintext highlighter-rouge">Cancelable.empty</code> in case the executed
process really can’t be canceled in time, but you should strive to
return a cancelable that does cancel your execution, if possible.</li>
</ul>
    
      <h2 id="memoization">
        
        
          Memoization <a href="#memoization" class="anchor">#</a>
        
        
      </h2>

<p>The
<a href="/api/current/monix/eval/Task.html#memoize:monix.eval.Task[A]">Task#memoize</a>
operator can take any <code class="language-plaintext highlighter-rouge">Task</code> and apply memoization on the first <code class="language-plaintext highlighter-rouge">runToFuture</code>,
such that:</p>

<ol>
  <li>you have guaranteed idempotency, calling <code class="language-plaintext highlighter-rouge">runToFuture</code> multiple times
will have the same effect as calling it once</li>
  <li>subsequent <code class="language-plaintext highlighter-rouge">runToFuture</code> calls will reuse the result computed by the
first <code class="language-plaintext highlighter-rouge">runToFuture</code></li>
</ol>

<p>So <code class="language-plaintext highlighter-rouge">memoize</code> effectively caches the result of the first <code class="language-plaintext highlighter-rouge">runToFuture</code>.
In fact we can say that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">evalOnce</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">&lt;-&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="py">memoize</span>
</code></pre></div></div>

<p>They are effectively the same.  And <code class="language-plaintext highlighter-rouge">memoize</code> works
with any task reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Has async execution, to do the .apply semantics</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">memoized</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">memoize</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect</span>
<span class="c1">//=&gt; Hello!</span>

<span class="nv">memoized</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Hello!</span>
</code></pre></div></div>
    
      <h3 id="memoize-only-on-success">
        
        
          Memoize Only on Success <a href="#memoize-only-on-success" class="anchor">#</a>
        
        
      </h3>

<p>Sometimes you just want memoization, along with idempotency
guarantees, only for successful values. For failures you might want to
keep retrying until a successful value is available.</p>

<p>This is where the <code class="language-plaintext highlighter-rouge">memoizeOnSuccess</code> operator comes in handy:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">effect</span> <span class="k">=</span> <span class="mi">0</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span> <span class="o">{</span>
  <span class="n">effect</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="nf">if</span> <span class="o">(</span><span class="n">effect</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">"dummy"</span><span class="o">)</span> <span class="k">else</span> <span class="n">effect</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">cached</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">memoizeOnSuccess</span>

<span class="k">val</span> <span class="nv">f1</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// yields RuntimeException</span>
<span class="k">val</span> <span class="nv">f2</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// yields RuntimeException</span>
<span class="k">val</span> <span class="nv">f3</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// yields 3</span>
<span class="k">val</span> <span class="nv">f4</span> <span class="k">=</span> <span class="nv">cached</span><span class="o">.</span><span class="py">runToFuture</span> <span class="c1">// yields 3</span>
</code></pre></div></div>
    
      <h3 id="memoize-versus-runtofuture">
        
        
          Memoize versus runToFuture <a href="#memoize-versus-runtofuture" class="anchor">#</a>
        
        
      </h3>

<p>You can say that when we do this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span><span class="o">);</span> <span class="s">"Hello!"</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>
</code></pre></div></div>

<p>That <code class="language-plaintext highlighter-rouge">future</code> instance is also going to be a memoized value of the
first <code class="language-plaintext highlighter-rouge">runToFuture</code> execution, which can be reused for other <code class="language-plaintext highlighter-rouge">onComplete</code>
subscribers.</p>

<p>The difference is the same as the difference between <code class="language-plaintext highlighter-rouge">Task</code> and
<code class="language-plaintext highlighter-rouge">Future</code>. The <code class="language-plaintext highlighter-rouge">memoize</code> operation is lazy, evaluation only being
triggered on the first <code class="language-plaintext highlighter-rouge">runToFuture</code>, whereas the result of <code class="language-plaintext highlighter-rouge">runToFuture</code> is
eager.</p>
    
      <h2 id="operations">
        
        
          Operations <a href="#operations" class="anchor">#</a>
        
        
      </h2>
    
      <h3 id="flatmap-and-tail-recursive-loops">
        
        
          FlatMap and Tail-Recursive Loops <a href="#flatmap-and-tail-recursive-loops" class="anchor">#</a>
        
        
      </h3>

<p>So let’s start with a simple example that calculates the N-th number in
the Fibonacci sequence:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="nd">@tailrec</span>
<span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
 <span class="k">else</span>
   <span class="n">b</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We need this to be tail-recursive, hence the use of the
<a href="http://www.scala-lang.org/api/current/index.html#scala.annotation.tailrec">@tailrec</a>
annotation from Scala’s standard library. And if we’d describe it with
<code class="language-plaintext highlighter-rouge">Task</code>, one possible implementation would be:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
 <span class="nf">if</span> <span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">defer</span><span class="o">(</span><span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">))</span>
 <span class="k">else</span>
   <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now there are already differences. This is lazy, as the N-th
Fibonacci number won’t get calculated until we <code class="language-plaintext highlighter-rouge">runToFuture</code>. The
<code class="language-plaintext highlighter-rouge">@tailrec</code> annotation is also not needed, as this is stack (and heap)
safe.</p>

<p><code class="language-plaintext highlighter-rouge">Task</code> has <code class="language-plaintext highlighter-rouge">flatMap</code>, which is the monadic <code class="language-plaintext highlighter-rouge">bind</code> operation, that for
things like <code class="language-plaintext highlighter-rouge">Task</code> and <code class="language-plaintext highlighter-rouge">Future</code> is the operation that describes
recursivity or that forces ordering (e.g. execute this, then that,
then that). And we can use it to describe recursive calls:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
    <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span>
      <span class="nf">fib</span><span class="o">(</span><span class="n">cycles</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>
    <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory, so no
<code class="language-plaintext highlighter-rouge">@tailrec</code> annotation is needed or wanted. And it has lazy behavior,
as nothing will get triggered until <code class="language-plaintext highlighter-rouge">runToFuture</code> happens.</p>

<p>But we can also have <strong>mutually tail-recursive calls</strong>, w00t!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Mutual Tail Recursion, ftw!!!</span>
<span class="o">{</span>
  <span class="k">def</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="nf">even</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">).</span><span class="py">flatMap</span> <span class="o">{</span>
      <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
      <span class="k">case</span> <span class="kc">false</span> <span class="k">=&gt;</span> <span class="nf">odd</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="nf">even</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Again, this is stack safe and uses a constant amount of memory.  And
best of all, because of the
<a href="/docs/current/execution/scheduler.html#execution-model">execution model</a>, by
default these loops won’t block the current thread forever, preferring to
execute things in batches.</p>
    
      <h3 id="parallelism-catsparallel">
        
        
          Parallelism (cats.Parallel) <a href="#parallelism-catsparallel" class="anchor">#</a>
        
        
      </h3>

<p>When using <code class="language-plaintext highlighter-rouge">flatMap</code>, we often end up with this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// Ordered operations based on flatMap ...</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">location</span> <span class="k">&lt;-</span> <span class="n">locationTask</span>
  <span class="n">phone</span> <span class="k">&lt;-</span> <span class="n">phoneTask</span>
  <span class="n">address</span> <span class="k">&lt;-</span> <span class="n">addressTask</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">{</span>
  <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>For one the problem here is that these operations are executed in
order. This also happens with Scala’s standard <code class="language-plaintext highlighter-rouge">Future</code>, being
sometimes an unwanted effect, but because <code class="language-plaintext highlighter-rouge">Task</code> is lazily evaluated,
this effect is even more pronounced with <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>But <code class="language-plaintext highlighter-rouge">Task</code> also has a
<a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a>
implementation, being able to trigger evaluation of multiple
tasks in parallel and hence it has utilities, such
as <code class="language-plaintext highlighter-rouge">parZip2</code>, <code class="language-plaintext highlighter-rouge">parZip3</code>, up until <code class="language-plaintext highlighter-rouge">parZip6</code> (at the moment of writing). 
The example above could be written as:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">locationTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">phoneTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>
<span class="k">val</span> <span class="nv">addressTask</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(???)</span>

<span class="c1">// Potentially executed in parallel</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">parZip3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="py">map</span> <span class="o">{</span>
    <span class="nf">case</span> <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>In order to avoid boxing into tuples, you can also use <code class="language-plaintext highlighter-rouge">parMap2</code>,
<code class="language-plaintext highlighter-rouge">parMap3</code> … <code class="language-plaintext highlighter-rouge">parMap6</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Task</span><span class="o">.</span><span class="py">parMap3</span><span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And you can use Cats’ syntax for <code class="language-plaintext highlighter-rouge">parMapN</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.all._</span>

<span class="o">(</span><span class="n">locationTask</span><span class="o">,</span> <span class="n">phoneTask</span><span class="o">,</span> <span class="n">addressTask</span><span class="o">).</span><span class="py">parMapN</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">location</span><span class="o">,</span> <span class="n">phone</span><span class="o">,</span> <span class="n">address</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"Gotcha!"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Also see the documentation for
<a href="https://typelevel.org/cats/typeclasses/parallel.html">cats.Parallel</a>.</p>
    
      <h3 id="gather-results-from-a-seq-of-tasks">
        
        
          Gather results from a Seq of Tasks <a href="#gather-results-from-a-seq-of-tasks" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.sequence</code>, takes a <code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code> and returns a <code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>,
thus transforming any sequence of tasks into a task with a sequence of
results and with ordered effects and results. This means that the
tasks WILL NOT execute in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="c1">// We always get this ordering:</span>
<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p>The results are ordered in the order of the initial sequence, so that
means in the example above we are guaranteed in the result to first
get the result of <code class="language-plaintext highlighter-rouge">ta</code> (the first task) and then the result of <code class="language-plaintext highlighter-rouge">tb</code>
(the second task). The execution itself is also ordered, so <code class="language-plaintext highlighter-rouge">ta</code>
executes and completes before <code class="language-plaintext highlighter-rouge">tb</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Task.parSequence</code>, similar to <code class="language-plaintext highlighter-rouge">Parallel.parSequence</code>, is the nondeterministic
version of <code class="language-plaintext highlighter-rouge">Task.sequence</code>.  It also takes a <code class="language-plaintext highlighter-rouge">Seq[Task[A]]</code> and
returns a <code class="language-plaintext highlighter-rouge">Task[Seq[A]]</code>, thus transforming any sequence of tasks into
a task with a sequence of ordered results. But the effects are not
ordered, meaning that there’s potential for parallel execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.parSequenceUnordered</code> is like <code class="language-plaintext highlighter-rouge">parSequence</code>, except that you don’t get
ordering for results or effects. The result is thus highly nondeterministic,
but yields better performance than <code class="language-plaintext highlighter-rouge">parSequence</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect1"</span><span class="o">);</span> <span class="mi">1</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect2"</span><span class="o">);</span> <span class="mi">2</span> <span class="o">}</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">parSequenceUnordered</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Seq(2,1)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Seq(1,2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.traverse</code>, takes a <code class="language-plaintext highlighter-rouge">Seq[A]</code>, <code class="language-plaintext highlighter-rouge">f: A =&gt; Task[B]</code> and returns a <code class="language-plaintext highlighter-rouge">Task[Seq[B]]</code>.
This is similar to <code class="language-plaintext highlighter-rouge">Task.sequence</code> but it uses <code class="language-plaintext highlighter-rouge">f</code> to generate each <code class="language-plaintext highlighter-rouge">Task</code>.</p>

<p>All <code class="language-plaintext highlighter-rouge">Task.sequence</code> semantics hold meaning the effects are ordered and the tasks
WILL NOT execute in parallel.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">traverse</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="c1">// We always get this ordering:</span>
<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.parTraverse</code>, similar to <code class="language-plaintext highlighter-rouge">Parallel.parTraverse</code>, is the nondeterministic
version of <code class="language-plaintext highlighter-rouge">Task.traverse</code>.  It also takes a <code class="language-plaintext highlighter-rouge">Seq[A]</code>, <code class="language-plaintext highlighter-rouge">f: A =&gt; Task[B]</code> and
returns a <code class="language-plaintext highlighter-rouge">Task[Seq[B]]</code>. It applies <code class="language-plaintext highlighter-rouge">f</code> to each element in the sequence transforming it
into <code class="language-plaintext highlighter-rouge">Task</code> and then collecting results. The order in the output sequence is preserved, but 
the effects are not ordered, meaning that there’s potential for parallel execution:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">def</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> 
  <span class="nc">Task</span> <span class="o">{</span> <span class="nf">println</span><span class="o">(</span><span class="s">"Effect"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span> <span class="n">i</span> <span class="o">}.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">list</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parTraverse</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nf">task</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; List(1, 2)</span>

<span class="nv">list</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Effect2</span>
<span class="c1">//=&gt; Effect1</span>
<span class="c1">//=&gt; List(1, 2)</span>
</code></pre></div></div>

<p>Similar to <code class="language-plaintext highlighter-rouge">parSequenceUnordered</code> there is also unordered version of <code class="language-plaintext highlighter-rouge">parTraverse</code> called <code class="language-plaintext highlighter-rouge">parTraverseUnordered</code>.</p>

<p><strong>NOTE:</strong> If you have the possibility, prefer explicitly using <code class="language-plaintext highlighter-rouge">Task</code> operators instead of
those provided by Cats syntax. Their default implementations are derived from other
methods and are often much slower than optimized <code class="language-plaintext highlighter-rouge">Task</code> versions.</p>

<p>Refer to the table below to see corresponding methods:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Monix</th>
      <th style="text-align: center">Cats</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Task.sequence</td>
      <td style="text-align: center">Traverse[F].sequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.traverse</td>
      <td style="text-align: center">Traverse[F].traverse</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.parSequence</td>
      <td style="text-align: center">Parallel.parSequence</td>
    </tr>
    <tr>
      <td style="text-align: center">Task.parTraverse</td>
      <td style="text-align: center">Parallel.parTraverse</td>
    </tr>
  </tbody>
</table>
    
      <h3 id="race">
        
        
          Race <a href="#race" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">racePair</code> operation will choose the winner between two
<code class="language-plaintext highlighter-rouge">Task</code> that will potentially run in parallel:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">race</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">racePair</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">).</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Left</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">fiber</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"A succeeded: $a"</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">Right</span><span class="o">((</span><span class="n">fiber</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nv">fiber</span><span class="o">.</span><span class="py">cancel</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"B succeeded: $b"</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The result generated will be an <code class="language-plaintext highlighter-rouge">Either</code> of tuples, giving you the
opportunity to do something with the other task that lost the race.
You can cancel it, or you can use its result somehow, or you can
simply ignore it, your choice depending on use-case.</p>
    
      <h3 id="race-many">
        
        
          Race Many <a href="#race-many" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">raceMany</code> operation takes as input a list of tasks,
and upon execution will generate the result of the first task
that completes and wins the race:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">ta</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tb</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="n">ta</span><span class="o">,</span> <span class="n">tb</span><span class="o">))</span>
    <span class="o">.</span><span class="py">runToFuture</span>
    <span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Winner: $r"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It is similar to Scala’s
<a href="http://www.scala-lang.org/api/current/index.html#scala.concurrent.Future$@firstCompletedOf[T](futures:TraversableOnce[scala.concurrent.Future[T]])(implicitexecutor:scala.concurrent.ExecutionContext):scala.concurrent.Future[T]">Future.firstCompletedOf</a>
operation, except that it operates on <code class="language-plaintext highlighter-rouge">Task</code> and upon execution it has
a better model, as when a task wins the race the other tasks get
immediately canceled.</p>

<p>If you want to ignore errors and wait for the first successful result you could 
combine it with <code class="language-plaintext highlighter-rouge">onErrorHandleWith</code> and <code class="language-plaintext highlighter-rouge">timeout</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">timeout</span> <span class="k">=</span> <span class="mf">30.</span><span class="n">second</span>

<span class="k">val</span> <span class="nv">task1</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task2</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task3</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tasks</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">task1</span><span class="o">,</span> <span class="n">task2</span><span class="o">,</span> <span class="n">task3</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">))).</span><span class="py">timeout</span><span class="o">(</span><span class="n">timeout</span><span class="o">)</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">result</span><span class="o">.</span><span class="py">runSyncUnsafe</span><span class="o">())</span> <span class="c1">// will print 10</span>
</code></pre></div></div>
<p>It will turn any failed tasks into non-terminating.</p>

<p>Timeout is necessary in case all tasks fail. In the example above, if <code class="language-plaintext highlighter-rouge">task1</code> also fails we will have to wait for the timeout
to expire despite knowing that we won’t get any successful result.</p>

<p>We can optimize it by doing second <code class="language-plaintext highlighter-rouge">race </code>that uses <code class="language-plaintext highlighter-rouge">Semaphore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect.concurrent.Semaphore</span>
<span class="k">import</span> <span class="nn">cats.syntax.apply._</span>
<span class="k">import</span> <span class="nn">monix.eval.Task</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="k">import</span> <span class="nn">monix.execution.exceptions.DummyException</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">task1</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task2</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">2.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">task3</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="nc">DummyException</span><span class="o">(</span><span class="s">"error"</span><span class="o">)).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">tasks</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">task1</span><span class="o">,</span> <span class="n">task2</span><span class="o">,</span> <span class="n">task3</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">semaphore</span> <span class="k">=</span> <span class="nc">Semaphore</span><span class="o">[</span><span class="kt">Task</span><span class="o">](</span><span class="mi">0</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">result</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">Unit</span>, <span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nv">semaphore</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">sem</span> <span class="k">=&gt;</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">race</span><span class="o">(</span>
    <span class="nv">sem</span><span class="o">.</span><span class="py">acquireN</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">length</span><span class="o">),</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raceMany</span><span class="o">(</span><span class="nv">tasks</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">onErrorHandleWith</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nv">sem</span><span class="o">.</span><span class="py">release</span> <span class="o">*&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">never</span><span class="o">)))</span>
  <span class="o">)</span>
<span class="o">}</span>

<span class="nf">println</span><span class="o">(</span><span class="nv">result</span><span class="o">.</span><span class="py">runSyncUnsafe</span><span class="o">())</span> <span class="c1">// will finish and print after 3 seconds</span>
</code></pre></div></div>
    
      <h3 id="delay-execution">
        
        
          Delay Execution <a href="#delay-execution" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayExecution</code>, as the name says, delays the execution of a
given task by the given timespan.</p>

<p>In this example we are delaying the execution of the source by 3
seconds:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="nv">delayed</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Or, instead of a delay we might want to use another <code class="language-plaintext highlighter-rouge">Task</code> as the
signal for starting the execution, so the following example is
equivalent to the one above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
  <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="py">flatMap</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">source</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="delay-signaling-of-the-result">
        
        
          Delay Signaling of the Result <a href="#delay-signaling-of-the-result" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.delayResult</code> delays the signaling of the result, but not the
execution of the <code class="language-plaintext highlighter-rouge">Task</code>. Consider this example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
  <span class="nf">println</span><span class="o">(</span><span class="s">"Side-effect!"</span><span class="o">)</span>
  <span class="s">"Hello, world!"</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">delayed</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">source</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayResult</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">delayed</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</code></pre></div></div>

<p>Here, you’ll see the “side-effect happening after only 1 second, but
the signaling of the result will happen after another 5 seconds.</p>
    
      <h3 id="restart-until-predicate-is-true">
        
        
          Restart Until Predicate is True <a href="#restart-until-predicate-is-true" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> being a spec, we can restart it at will.
<code class="language-plaintext highlighter-rouge">Task.restartUntil(predicate)</code> does just that, executing the source
over and over again, until the given predicate is true:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>
    <span class="o">.</span><span class="py">restartUntil</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; -2097793116</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1246761488</span>
<span class="nv">randomEven</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 1053678416</span>
</code></pre></div></div>
    
      <h3 id="clean-up-resources-on-finish">
        
        
          Clean-up Resources on Finish <a href="#clean-up-resources-on-finish" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.doOnFinish</code> executes the supplied
<code class="language-plaintext highlighter-rouge">Option[Throwable] =&gt; Task[Unit]</code> function when the source finishes,
being meant for cleaning up resources or executing
some scheduled side-effect:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">withFinishCb</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">doOnFinish</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Was success!"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Had failure: $ex"</span><span class="o">)</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">unit</span>
<span class="o">}</span>

<span class="nv">withFinishCb</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Was success!</span>
<span class="c1">//=&gt; 1</span>
</code></pre></div></div>
    
      <h3 id="convert-to-reactive-publisher">
        
        
          Convert to Reactive Publisher <a href="#convert-to-reactive-publisher" class="anchor">#</a>
        
        
      </h3>

<p>Did you know that Monix integrates with the
<a href="http://www.reactive-streams.org/">Reactive Streams</a>
specification?</p>

<p>Well, <code class="language-plaintext highlighter-rouge">Task</code> can be seen as an <code class="language-plaintext highlighter-rouge">org.reactivestreams.Publisher</code> that
emits exactly one event upon subscription and then stops. And we can
convert any <code class="language-plaintext highlighter-rouge">Task</code> to such a publisher directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">())</span>

<span class="k">val</span> <span class="nv">publisher</span><span class="k">:</span> <span class="kt">org.reactivestreams.Publisher</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nv">task</span><span class="o">.</span><span class="py">toReactivePublisher</span>
</code></pre></div></div>

<p>This is meant for interoperability purposes with other libraries, but
if you’re inclined to use it directly, it’s a little lower level,
but doable:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.reactivestreams._</span>

<span class="nv">publisher</span><span class="o">.</span><span class="py">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="nc">Subscriber</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Subscription</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">s</span><span class="o">.</span><span class="py">request</span><span class="o">(</span><span class="nv">Long</span><span class="o">.</span><span class="py">MaxValue</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="n">s</span><span class="s">"OnNext: $e"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onComplete</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"OnComplete"</span><span class="o">)</span>

  <span class="k">def</span> <span class="nf">onError</span><span class="o">(</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nv">System</span><span class="o">.</span><span class="py">err</span><span class="o">.</span><span class="py">println</span><span class="o">(</span><span class="n">s</span><span class="s">"ERROR: $ex"</span><span class="o">)</span>
<span class="o">})</span>

<span class="c1">// Will print:</span>
<span class="c1">//=&gt; OnNext: -228329246</span>
<span class="c1">//=&gt; OnComplete</span>
</code></pre></div></div>

<p>Awesome, isn’t it?</p>

<p>(◑‿◐)</p>
    
      <h2 id="error-handling">
        
        
          Error Handling <a href="#error-handling" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">Task</code> takes error handling very seriously. You see, there’s this famous
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">thought experiment</a>
regarding <em>observation</em>:</p>

<blockquote>
  <p>“<em>If a tree falls in a forest and no one is around to hear it, does
it make a sound?</em>”</p>
</blockquote>

<p>Now this applies very well to error handling, because if an error is
triggered by an asynchronous process and there’s nobody to hear it, no
handler to catch it and log it or recover from it, then it didn’t
happen. And what you’ll get is
<a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">nondeterminism</a>
without any hints of the error involved.</p>

<p>This is why Monix will always attempt to catch and signal or at least
log any errors that happen. In case signaling is not possible for
whatever reason (like the callback was already called), then the
logging is done by means of the provided <code class="language-plaintext highlighter-rouge">Scheduler.reportFailure</code>,
which defaults to <code class="language-plaintext highlighter-rouge">System.err</code>, unless you provide something more
concrete, like going through SLF4J or whatever.</p>

<p>Even though Monix expects for the arguments given to its operators,
like <code class="language-plaintext highlighter-rouge">flatMap</code>, to be pure or at least protected from errors, it still
catches errors, signaling them on <code class="language-plaintext highlighter-rouge">runAsync</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">odd</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">odd</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Right(-924040280)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(java.lang.IllegalStateException: 834919637)</span>
</code></pre></div></div>

<p>In case an error happens in the callback provided to <code class="language-plaintext highlighter-rouge">runAsync</code>, then
Monix can no longer signal an <code class="language-plaintext highlighter-rouge">onError</code>, because it would be a
contract violation (see <a href="/docs/current/execution/callback.html">Callback</a>). But it still
logs the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="c1">// Ensures asynchronous execution, just to show</span>
<span class="c1">// that the action doesn't happen on the</span>
<span class="c1">// current thread</span>
<span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>

<span class="nv">task</span><span class="o">.</span><span class="py">runAsync</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">r</span><span class="o">.</span><span class="py">toString</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// After 1 second, this will log the whole stack trace:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: Right(2)</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt;	at monix.eval.Task$$anon$3.onSuccess(Task.scala:78)</span>
<span class="c1">//=&gt;	at monix.eval.Callback$SafeCallback.onSuccess(Callback.scala:66)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.trampoline$1(Task.scala:1248)</span>
<span class="c1">//=&gt;	at monix.eval.Task$.monix$eval$Task$$resume(Task.scala:1304)</span>
<span class="c1">//=&gt;	at monix.eval.Task$AsyncStateRunnable$$anon$20.onSuccess(Task.scala:1432)</span>
<span class="c1">//=&gt;    ....</span>
</code></pre></div></div>

<p>Similarly, when using <code class="language-plaintext highlighter-rouge">Task.create</code>, Monix attempts to catch any
uncaught errors, but because we did not know what happened in the
provided callback, we cannot signal the error as it would be a
contract violation (see <a href="/docs/current/execution/callback.html">Callback</a>), but Monix does
log the error:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">task</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">create</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">,</span> <span class="n">callback</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"FTW!"</span><span class="o">))</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">future</span> <span class="k">=</span> <span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span>

<span class="c1">// Logs the following to System.err:</span>
<span class="c1">//=&gt; java.lang.IllegalStateException: FTW!</span>
<span class="c1">//=&gt;    ...</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:576)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$$anonfun$create$1.apply(Task.scala:571)</span>
<span class="c1">//=&gt; 	at monix.eval.Task$AsyncStateRunnable.run(Task.scala:1429)</span>
<span class="c1">//=&gt;    ...</span>

<span class="c1">// The Future NEVER COMPLETES, OOPS!</span>
<span class="nv">future</span><span class="o">.</span><span class="py">onComplete</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><strong>WARNING:</strong> In this case the consumer side never gets a completion
signal. The moral of the story is: even if Monix makes a best effort
to do the right thing, you should protect your freaking code against
unwanted exceptions, especially in <code class="language-plaintext highlighter-rouge">Task.create</code>!!!</p>
    
      <h3 id="overriding-the-error-logging">
        
        
          Overriding the Error Logging <a href="#overriding-the-error-logging" class="anchor">#</a>
        
        
      </h3>

<p>The article on <a href="/docs/current/execution/scheduler.html">Scheduler</a> has recipes
for building your own <code class="language-plaintext highlighter-rouge">Scheduler</code> instances, with your own logic. But
here’s a quick snippet for building such a <code class="language-plaintext highlighter-rouge">Scheduler</code> that could do
logging by means of a library, such as the standard
<a href="http://www.slf4j.org/">SLF4J</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.execution.Scheduler</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.</span><span class="o">{</span><span class="n">global</span> <span class="k">=&gt;</span> <span class="n">default</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">monix.execution.UncaughtExceptionReporter</span>
<span class="k">import</span> <span class="nn">org.slf4j.LoggerFactory</span>

<span class="k">val</span> <span class="nv">reporter</span> <span class="k">=</span> <span class="nc">UncaughtExceptionReporter</span> <span class="o">{</span> <span class="n">ex</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">logger</span> <span class="k">=</span> <span class="nv">LoggerFactory</span><span class="o">.</span><span class="py">getLogger</span><span class="o">(</span><span class="s">"monix"</span><span class="o">)</span>
  <span class="nv">logger</span><span class="o">.</span><span class="py">error</span><span class="o">(</span><span class="s">"Uncaught exception"</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="nv">global</span><span class="k">:</span> <span class="kt">Scheduler</span> <span class="o">=</span>
  <span class="nc">Scheduler</span><span class="o">(</span><span class="n">default</span><span class="o">,</span> <span class="n">reporter</span><span class="o">)</span>
</code></pre></div></div>
    
      <h3 id="trigger-a-timeout">
        
        
          Trigger a Timeout <a href="#trigger-a-timeout" class="anchor">#</a>
        
        
      </h3>

<p>In case a <code class="language-plaintext highlighter-rouge">Task</code> is too slow to execute, we can cancel it and trigger
a <code class="language-plaintext highlighter-rouge">TimeoutException</code> using <code class="language-plaintext highlighter-rouge">Task.timeout</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="c1">// Triggers error if the source does not</span>
<span class="c1">// complete in 3 seconds after runAsync</span>
<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Failure(TimeoutException)</span>
</code></pre></div></div>

<p>On timeout the source gets canceled (if it’s a source that supports
cancelation). And instead of an error, we can timeout to a <code class="language-plaintext highlighter-rouge">fallback</code>
task. The following example is equivalent to the above one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">).</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">timedOut</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">timeoutTo</span><span class="o">(</span>
  <span class="mf">3.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimeoutException</span><span class="o">)</span>
<span class="o">)</span>

<span class="nv">timedOut</span><span class="o">.</span><span class="py">runAsync</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
<span class="c1">//=&gt; Left(TimeoutException)</span>
</code></pre></div></div>
    
      <h3 id="recovering-from-error">
        
        
          Recovering from Error <a href="#recovering-from-error" class="anchor">#</a>
        
        
      </h3>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code> is an operation that takes a function mapping
possible exceptions to a desired fallback outcome, so we could do
this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.TimeoutException</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Task</span><span class="o">(</span><span class="s">"Hello!"</span><span class="o">)</span>
    <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
    <span class="o">.</span><span class="py">timeout</span><span class="o">(</span><span class="mf">3.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="c1">// We have no idea what happened, raise error!</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">other</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p>There’s also <code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code> that takes a partial function
instead, so we can omit the “other” branch:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecoverWith</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="s">"Recovered!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; Recovered!</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Task.onErrorHandleWith</code> and <code class="language-plaintext highlighter-rouge">Task.onErrorRecoverWith</code> are the
equivalent of <code class="language-plaintext highlighter-rouge">flatMap</code>, only for errors. In case we know or can
evaluate a fallback result eagerly, we could use the shortcut
operation <code class="language-plaintext highlighter-rouge">Task.onErrorHandle</code> like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandle</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="s">"Recovered!"</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="k">throw</span> <span class="n">other</span> <span class="c1">// Rethrowing</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or the partial function version with <code class="language-plaintext highlighter-rouge">onErrorRecover</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRecover</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">TimeoutException</span> <span class="o">=&gt;</span>
    <span class="c1">// Oh, we know about timeouts, recover it</span>
    <span class="s">"Recovered!"</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="restart-on-error">
        
        
          Restart On Error <a href="#restart-on-error" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> type, being just a specification, it can usually restart
whatever process is supposed to deliver the final result and we can
restart the source on error, for how many times are needed:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will retry 4 times for a random even number,</span>
<span class="c1">// or fail if the maxRetries is reached!</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestart</span><span class="o">(</span><span class="n">maxRetries</span> <span class="k">=</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>We can also restart with a given predicate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nc">Task</span><span class="o">(</span><span class="nv">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">()).</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">even</span> <span class="k">if</span> <span class="n">even</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">even</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">other</span> <span class="k">=&gt;</span>
    <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="nv">other</span><span class="o">.</span><span class="py">toString</span><span class="o">))</span>
<span class="o">}</span>

<span class="c1">// Will keep retrying for as long as the source fails</span>
<span class="c1">// with an IllegalStateException</span>
<span class="k">val</span> <span class="nv">randomEven</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">onErrorRestartIf</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">IllegalStateException</span> <span class="o">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or we could implement our own retry with exponential backoff, because
it’s cool doing so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retryBackoff</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">source</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
  <span class="n">maxRetries</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">firstDelay</span><span class="k">:</span> <span class="kt">FiniteDuration</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="nv">source</span><span class="o">.</span><span class="py">onErrorHandleWith</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span>
      <span class="nf">if</span> <span class="o">(</span><span class="n">maxRetries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
        <span class="c1">// Recursive call, it's OK as Monix is stack-safe</span>
        <span class="nf">retryBackoff</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">maxRetries</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">firstDelay</span><span class="o">*</span><span class="mi">2</span><span class="o">)</span>
          <span class="o">.</span><span class="py">delayExecution</span><span class="o">(</span><span class="n">firstDelay</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
    
      <h3 id="expose-errors">
        
        
          Expose Errors <a href="#expose-errors" class="anchor">#</a>
        
        
      </h3>

<p>The <code class="language-plaintext highlighter-rouge">Task</code> monadic context is hiding errors that happen, much like
Scala’s <code class="language-plaintext highlighter-rouge">Try</code> or <code class="language-plaintext highlighter-rouge">Future</code>. But sometimes we want to expose those
errors such that we can recover more efficiently:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Try</span><span class="o">,</span> <span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">materialized</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>

<span class="c1">// Now we can flatMap over both success and failure:</span>
<span class="k">val</span> <span class="nv">recovered</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">now</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>

<span class="nv">recovered</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 0</span>
</code></pre></div></div>

<p>There’s also the reverse of materialize, which is <code class="language-plaintext highlighter-rouge">Task.dematerialize</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Try</span>

<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="c1">// Exposing errors</span>
<span class="k">val</span> <span class="nv">materialized</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">materialize</span>
<span class="c1">// materialize: Task[Try[Int]] = ???</span>

<span class="c1">// Hiding errors again</span>
<span class="k">val</span> <span class="nv">dematerialized</span> <span class="k">=</span> <span class="nv">materialized</span><span class="o">.</span><span class="py">dematerialize</span>
<span class="c1">// dematerialized: Task[Int] = ???</span>
</code></pre></div></div>

<p>We can also convert any <code class="language-plaintext highlighter-rouge">Task</code> into a <code class="language-plaintext highlighter-rouge">Task[Throwable]</code> that will
expose any errors that happen and will also terminate with an
<code class="language-plaintext highlighter-rouge">NoSuchElementException</code> in case the source completes with success:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">raiseError</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">)</span>

<span class="k">val</span> <span class="nv">throwable</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">failed</span>
<span class="c1">// throwable: Task[Throwable] = ???</span>

<span class="nv">throwable</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; java.lang.IllegalStateException</span>
</code></pre></div></div>


  <div class="buttons">
    <a href="/docs/current/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/eval/task.md">
      ページを編集</a> •
    
    <a href="https://gitter.im/monix/monix">
      チャットに参加</a> •
    <a href="/social.html">
      フォロー</a>
  </div>

  </div>
      </article>
    </div>
    <script type="text/javascript">
  var _paq = window._paq || [];
  // Disabling cookies for privacy reasons
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://ly.monix.io/";
    _paq.push(['setTrackerUrl', u+'m.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'m.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript>
  
  <img src="https://ly.monix.io/m.php?idsite=2&rec=1&action_name=Task" style="border:0" alt="" />
</noscript>


  </body>
</html>
