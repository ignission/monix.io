<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  
  <title>並列処理 &mdash; Monix</title>

  <link rel="canonical" href="https://monix.io/docs/current/tutorials/parallelism.html" />

  <!-- Twitter Cards -->
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image:src" content="https://monix.io/public/images/monix-logo-rect.png">
  <meta name="twitter:site" content="@monix" />  
  <meta name="twitter:creator" content="@monix" />  
  <meta name="twitter:title" content="並列処理 &amp;mdash; Monix" />
  <meta name="twitter:description" content="並列化のためのレシピ" />
  <meta name="twitter:url" content="https://monix.io/docs/current/tutorials/parallelism.html">
  <!-- Facebook Open-Graph -->
  <meta property="fb:app_id" content="2160100887367418" />

  <meta content="Monix" property="og:site_name">
  <meta content="並列処理 &amp;mdash; Monix" property="og:title">
  <meta content="並列化のためのレシピ" property="og:description">
  <meta content="https://monix.io/docs/current/tutorials/parallelism.html" property="og:url">
  <meta content="2021-07-06T14:45:36+00:00" property="article:modified_time">
    
  <meta content="article" property="og:type">
  <meta property="og:image" content="https://monix.io/public/images/monix-logo.png" />
  <meta property="og:image:secure_url" content="https://monix.io/public/images/monix-logo.png" />
  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/all.css?1625754182468065957">
  <!--[if lt IE 9]>
  <link rel="stylesheet" href="/public/css/forkme.ie.css?1625754182468065957">
  <![endif]-->

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Web App Manifest, see: http://manifest.sysapps.org/ -->
  <link rel="manifest" href="/manifest.json">
  <!-- Icons -->
  <link rel="icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Mobile Safari / iOS Icons -->
  <link rel="apple-touch-icon" sizes="48x48" href="/public/icons/icon-48x48.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/public/icons/icon-72x72.png">
  <link rel="apple-touch-icon" sizes="96x96" href="/public/icons/icon-96x96.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/public/icons/icon-144x144.png">
  <link rel="apple-touch-icon" sizes="192x192" href="/public/icons/icon-192x192.png">
  <link rel="apple-touch-icon" sizes="240x240" href="/public/icons/icon-240x240.png">
  <link rel="apple-touch-icon" sizes="384x384" href="/public/icons/icon-384x384.png">
  <!-- Standard Favicon -->
  <link rel="shortcut icon" href="/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="Feed" href="/blog/atom.xml">
</head>


  <body class="monix layout">
    <div class="wrapper">
      <aside class="sidebar plus">
  <div class="container">
    <div class="sidebar-about">
      <a class="github-fork-ribbon left-top" href="https://github.com/monix/monix"
        title="Fork me on GitHub">Fork me on GitHub</a>

      <h1>
        <a href="/">
          <img src="/public/images/monix-logo.png"
            alt="Monix Logo" title="Monix" class="logo" />
        </a>
      </h1>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">About</a>
      <a class="sidebar-nav-item" href="/blog/">Blog</a>
      <a class="sidebar-nav-item active" href="/docs/current/">Documentation</a>
      <a class="sidebar-nav-item" href="/presentations/">Presentations</a>
      <a class="sidebar-nav-item" href="/social.html">Follow @Monix</a>
      <a class="sidebar-nav-item" href="/privacy.html">Privacy Policy</a>
    </nav>
  </div>
</aside>


      <article class="content container">
        <div class="page">
      <h1 class="page-title">
        
        
          並列処理
        
        
      </h1>

  
  <time class="post-date" itemprop="dateModified"
    datetime="2021-07-06">
    <b>ページの更新日:</b> 06 Jul 2021
  </time>
  <nav role="navigation" id="type-info">
    
    
    
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/tutorials/parallelism.md">ページを編集</a>
    
  </nav>
  
  <div id="version3x">
    最新のMonix 3.xシリーズのドキュメントが表示されています。<br/>
    古いバージョン:
    
      <a href="/docs/2x/tutorials/parallelism.html">2.x</a>
  </div>

  <nav role="navigation" id="toc">
    <ul>
  <li><a href="#taskでの並列処理">Taskでの並列処理</a>
    <ul>
      <li><a href="#ネイティブに使う">ネイティブに使う</a></li>
      <li><a href="#並列度制限の導入">並列度制限の導入</a></li>
      <li><a href="#batched-observables">Batched Observables</a></li>
    </ul>
  </li>
  <li><a href="#observablemapparallelunordered">Observable.mapParallelUnordered</a></li>
  <li><a href="#observablemergemap">Observable.mergeMap</a></li>
  <li><a href="#consumerloadbalancer">Consumer.loadBalancer</a></li>
</ul>

  </nav>

  <p>Monixでは、ユースケースに応じて複数の並列化の方法が用意されています。</p>

<p>このドキュメントのサンプルはコピー・ペースト可能ですが、importを整理します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 評価時にはスケジューラーが必要</span>
<span class="k">import</span> <span class="nn">monix.execution.Scheduler.Implicits.global</span>
<span class="c1">// Taskの使用に必要</span>
<span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="c1">// Observableの使用に必要</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>
</code></pre></div></div>
    
      <h2 id="taskでの並列処理">
        
        
          Taskでの並列処理 <a href="#taskでの並列処理" class="anchor">#</a>
        
        
      </h2>

<p><a href="/docs/current/eval/task.html">タスク</a> の助けを借りて、結果の決定論的(順序付けられた)シグナリングを行うバッチ単位の並列実行が可能です。</p>
    
      <h3 id="ネイティブに使う">
        
        
          ネイティブに使う <a href="#ネイティブに使う" class="anchor">#</a>
        
        
      </h3>

<p>次の例では，<a href="/api/current/monix/eval/Task$.htmll#parSequenceN[A](parallelism:Int)(in:Iterable[monix.eval.Task[A]]):monix.eval.Task[List[A]]">Task.parSequence</a> を使用しています。
これは、結果の順序を保持したまま並列処理を行うものです。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">items</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">1000</span>

<span class="c1">// 実行に必要なすべてのタスクのリスト</span>
<span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// 並列に処理する</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">tasks</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span>

<span class="c1">// 評価:</span>
<span class="nv">aggregate</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p>結果の順序が重要でない場合は、<code class="language-plaintext highlighter-rouge">parSequence</code>の代わりに<a href="/api/current/monix/eval/Task$.htmll#parSequenceUnordered[A](in:Iterable[monix.eval.Task[A]]):monix.eval.Task[List[A]]">Task.parSequenceUnordered</a> を使用できます。
ノンブロッキングで実行できるので、より良い結果が得られるかもしれません。</p>
    
      <h3 id="並列度制限の導入">
        
        
          並列度制限の導入 <a href="#並列度制限の導入" class="anchor">#</a>
        
        
      </h3>

<p>上の例のように、<code class="language-plaintext highlighter-rouge">Task.parSequence</code>ビルダーは与えられたすべてのタスクを潜在的に並列実行します。
しかし、問題はこれが非効率につながる可能性があるということです。
例えばHTTPリクエストを行っている場合、10000のHTTPリクエストを並行して実行することは、相手側のサーバーをダウンさせる可能性があるため必ずしも賢明ではありません。</p>

<p>この問題を解決するには、ワークロードを並列タスクのバッチに分割し、それを順番に実行します:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">items</span> <span class="k">=</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">1000</span>
<span class="c1">// 実行に必要なすべてのタスクのリスト</span>
<span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
<span class="c1">// 10個のタスクのバッチを構築して並列に実行する:</span>
<span class="k">val</span> <span class="nv">batches</span> <span class="k">=</span> <span class="nv">tasks</span><span class="o">.</span><span class="py">sliding</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">b</span><span class="o">)).</span><span class="py">toIterable</span>
<span class="c1">// バッチを配列にし、最終的な結果をフラットにする</span>
<span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="n">batches</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">.</span><span class="py">toList</span><span class="o">)</span>

<span class="c1">// 評価する:</span>
<span class="nv">aggregate</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p>この戦略はScalaの<code class="language-plaintext highlighter-rouge">Future</code>では実現が難しいことに注意してください。
なぜなら、<code class="language-plaintext highlighter-rouge">Future.sequence</code>があるにもかかわらず、その動作は厳密なものであるためシーケンスとパラレルをうまく使い分けることができません。
この動作は<code class="language-plaintext highlighter-rouge">Future.sequence</code>にlazyまたはstrictシーケンスを渡すことで制御されますが、これは明らかにエラーを起こしやすいです。</p>
    
      <h3 id="batched-observables">
        
        
          Batched Observables <a href="#batched-observables" class="anchor">#</a>
        
        
      </h3>

<p>これを<code class="language-plaintext highlighter-rouge">Observable.flatMap</code>と組み合わせて、リクエストをバッチ処理することもできます。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="c1">// `bufferIntrospective`は、ダウンストリームがビジー状態である限り、</span>
<span class="c1">// 特定の`bufferSize`までバッファリングされたすべてのイベントのシーケンスを</span>
<span class="c1">// 一度にストリーミングします。</span>
<span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">).</span><span class="py">bufferIntrospective</span><span class="o">(</span><span class="mi">256</span><span class="o">)</span>

<span class="c1">// バッチ処理には`Task`を使用しています</span>
<span class="k">val</span> <span class="nv">batched</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">flatMap</span> <span class="o">{</span> <span class="n">items</span> <span class="k">=&gt;</span>
  <span class="c1">// 実行に必要なすべてのタスクのリスト</span>
  <span class="k">val</span> <span class="nv">tasks</span> <span class="k">=</span> <span class="nv">items</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
  <span class="c1">// 10個のタスクを並列に実行するバッチの構築:</span>
  <span class="k">val</span> <span class="nv">batches</span> <span class="k">=</span> <span class="nv">tasks</span><span class="o">.</span><span class="py">sliding</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">10</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="nv">Task</span><span class="o">.</span><span class="py">parSequence</span><span class="o">(</span><span class="n">b</span><span class="o">)).</span><span class="py">toIterable</span>
  <span class="c1">// バッチを配列にし、最終的な結果をフラットにする</span>
  <span class="k">val</span> <span class="nv">aggregate</span> <span class="k">=</span> <span class="nv">Task</span><span class="o">.</span><span class="py">sequence</span><span class="o">(</span><span class="n">batches</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">flatten</span><span class="o">.</span><span class="py">iterator</span><span class="o">)</span>
  <span class="c1">// flatMapに必要なObservableへの変換</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">fromIterator</span><span class="o">(</span><span class="n">aggregate</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 評価:</span>
<span class="nv">batched</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 2, 4, 6, 8, 10, 12, 14, 16,...</span>
</code></pre></div></div>

<p><a href="/api/current/monix/reactive/Observable.html#bufferIntrospective(maxSize:Int):Self[List[A]]">bufferIntrospective</a> の使用に注意してください。
これは、ダウンストリームがビジー状態の間受信したイベントをバッファリングし、その後はバッファを1つのバンドルとして放出します。
<a href="/api/current/monix/reactive/Observable.html#bufferTumbling(count:Int):Self[Seq[A]]">bufferTumbling</a> のようなメソッドは、より決定性の高い代替手段となり得ます。</p>
    
      <h2 id="observablemapparallelunordered">
        
        
          Observable.mapParallelUnordered <a href="#observablemapparallelunordered" class="anchor">#</a>
        
        
      </h2>

<p>並列化を実現するもう一つの方法は<a href="/api/current/monix/reactive/Observable.html#mapParallelUnordered[B](parallelism:Int)(f:A=&gt;monix.eval.Task[B]):Self[B]">Observable.mapParallelUnordered</a> メソッドを使用することです:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">)</span>
<span class="c1">// 並列度を指定する必要があります</span>
<span class="k">val</span> <span class="nv">processed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">mapParallelUnordered</span><span class="o">(</span><span class="n">parallelism</span> <span class="k">=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nc">Task</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// 評価する:</span>
<span class="nv">processed</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(2, 10, 0, 4, 8, 6, 12...</span>
</code></pre></div></div>

<p>上記の例のように<code class="language-plaintext highlighter-rouge">Task.parSequence</code>を使用する場合と比較して、このメソッドではソースから通知された結果の<strong>順序は維持されません</strong>。</p>

<p>これは、少なくとも1つのワーカーがアクティブである限り、ソースがバックプレッシャーを受けることがないため、より効率的な実行につながります。
一方、上記の例のようなバッチ実行戦略では、1つの非同期タスクが完了するのに時間がかかりすぎて非効率になることがあります。</p>
    
      <h2 id="observablemergemap">
        
        
          Observable.mergeMap <a href="#observablemergemap" class="anchor">#</a>
        
        
      </h2>

<p>もし、<code class="language-plaintext highlighter-rouge">Observable.mapParallelUnordered</code>が<code class="language-plaintext highlighter-rouge">Task</code>で動作するならば、
<a href="https://monix.io/api/2.2/monix/reactive/Observable.html#mergeMap[B](f:A=%3Emonix.reactive.Observable[B])(implicitos:monix.reactive.OverflowStrategy[B]):Self[B]">Observable.mergeMap</a> は<code class="language-plaintext highlighter-rouge">Observable</code>のインスタンスをマージして動作します。</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="nv">source</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1000</span><span class="o">)</span>
<span class="c1">// 並列度を指定する必要があります</span>
<span class="k">val</span> <span class="nv">processed</span> <span class="k">=</span> <span class="nv">source</span><span class="o">.</span><span class="py">mergeMap</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span>
  <span class="nv">Observable</span><span class="o">.</span><span class="py">eval</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">).</span><span class="py">executeAsync</span>
<span class="o">}</span>

<span class="c1">// 評価する:</span>
<span class="nv">processed</span><span class="o">.</span><span class="py">toListL</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; List(0, 4, 6, 2, 8, 10, 12, 14...</span>
</code></pre></div></div>

<p>なお、<code class="language-plaintext highlighter-rouge">mergeMap</code>はソースから出力される観測可能なストリームを並行してサブスクライブされるため、
結果が非決定的であることを除いて<code class="language-plaintext highlighter-rouge">concatMap</code>(Monixでは<code class="language-plaintext highlighter-rouge">flatMap</code>のエイリアス)と似ています。</p>

<p>上の例のように、この <code class="language-plaintext highlighter-rouge">mergeMap</code> 呼び出しはオプションの<code class="language-plaintext highlighter-rouge">parallelism</code>パラメータを持っていないことに注意してください。
つまりソースがおしゃべりであれば、並行してサブスクライブされたオブザーバが <em>大量</em> にできてしまうということです。</p>

<p>問題は、<code class="language-plaintext highlighter-rouge">mergeMap</code>メソッドが実際の並列処理のためのものではなく、アクティブで同時進行しているストリームを結合するためのものです。</p>
    
      <h2 id="consumerloadbalancer">
        
        
          Consumer.loadBalancer <a href="#consumerloadbalancer" class="anchor">#</a>
        
        
      </h2>

<p><code class="language-plaintext highlighter-rouge">MapParallelUnordered</code>のような操作をconsumer側に適用することができます。
consumer側では、チュートリアルの<a href="./reactive/consumer.md">Consumer</a> で例示されているように負荷分散されたコンシューマーを使って、すべてのワーカーの結果を最終的に集約することができます:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">monix.eval._</span>
<span class="k">import</span> <span class="nn">monix.reactive._</span>

<span class="c1">// ストリームの要素を折り返すコンシューマ</span>
<span class="c1">// 結果として和を生成する</span>
<span class="k">val</span> <span class="nv">sumConsumer</span> <span class="k">=</span> <span class="nv">Consumer</span><span class="o">.</span><span class="py">foldLeft</span><span class="o">[</span><span class="kt">Long</span>,<span class="kt">Long</span><span class="o">](</span><span class="mi">0L</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// 合計を並列処理する場合はもちろん役に立たないが、</span>
<span class="c1">// I/Oに縛られたロジックには非常に有効である。</span>
<span class="k">val</span> <span class="nv">loadBalancer</span> <span class="k">=</span> <span class="o">{</span>
  <span class="nc">Consumer</span>
    <span class="o">.</span><span class="py">loadBalance</span><span class="o">(</span><span class="n">parallelism</span><span class="k">=</span><span class="mi">10</span><span class="o">,</span> <span class="n">sumConsumer</span><span class="o">)</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">sum</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="nv">observable</span><span class="k">:</span> <span class="kt">Observable</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nv">Observable</span><span class="o">.</span><span class="py">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100000</span><span class="o">)</span>
<span class="c1">// このコンシューマーは、observableをTaskの合計処理に変えてくれます w00t!</span>
<span class="k">val</span> <span class="nv">task</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nv">observable</span><span class="o">.</span><span class="py">consumeWith</span><span class="o">(</span><span class="n">loadBalancer</span><span class="o">)</span>

<span class="c1">// ストリーム全体を消費して結果を得る</span>
<span class="nv">task</span><span class="o">.</span><span class="py">runToFuture</span><span class="o">.</span><span class="py">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="c1">//=&gt; 4999950000</span>
</code></pre></div></div>

<p>詳しくは<a href="/docs/current/reactive/consumer.html">Consumer</a> をご覧ください。</p>


  <div class="buttons">
    <a href="/docs/current/">Contents</a> •
    <a href="https://github.com/monix/monix.io/blob/master/_docs/3x/tutorials/parallelism.md">
      ページを編集</a> •
    
    <a href="https://gitter.im/monix/monix">
      チャットに参加</a> •
    <a href="/social.html">
      フォロー</a>
  </div>

  </div>
      </article>
    </div>
    <script type="text/javascript">
  var _paq = window._paq || [];
  // Disabling cookies for privacy reasons
  _paq.push(['disableCookies']);
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="https://ly.monix.io/";
    _paq.push(['setTrackerUrl', u+'m.php']);
    _paq.push(['setSiteId', '2']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'m.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript>
  
  <img src="https://ly.monix.io/m.php?idsite=2&rec=1&action_name=%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86" style="border:0" alt="" />
</noscript>


  </body>
</html>
